<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Moxley Stratton </title>
		<link>http://www.moxleystratton.com/</link>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<author></author>
		<rights>Copyright (c) 2018</rights>
		<updated>2018-11-26 03:49:14 &#43;0000 UTC</updated>
		
		<item>
			<title>Visualizing Neuron Weights During Training</title>
			<link>http://www.moxleystratton.com/tensorflow-visualizing-weights/</link>
			<pubDate>Mon, 26 Nov 2018 03:49:14 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/tensorflow-visualizing-weights/</guid>
			<description>

&lt;p&gt;&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/moxicon-public/blog/tensorflow-visualizing-weights/two-weights-training-2.png&#34; alt=&#34;weights during training&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I have a deep interest in knowing exactly how a neural network works. Not only do
I want to know the theory, I want to know&amp;ndash; in practice&amp;ndash; what&amp;rsquo;s happening to the neuron&amp;rsquo;s weights
as the network is being trained.&lt;/p&gt;

&lt;p&gt;With TensorFlow, it took a lot of work and investigation to finally get to a point where I had something that
visualized weights being trained.&lt;/p&gt;

&lt;p&gt;It seemed that TensorFlow was putting roadblocks at every possible path to getting the valuees of the
changing weights. For graph calculations&amp;ndash; the kind that TensorFlow is based on&amp;ndash; it&amp;rsquo;s only possible
to read values in the graph during the graph&amp;rsquo;s session. That&amp;rsquo;s not an issue if you have a reference
to the session. But for models built with Keras, the session is created and destroyed behind
the scenes.&lt;/p&gt;

&lt;p&gt;I saw that TensorFlow provides a way to save a model&amp;rsquo;s state to a file. I tried digging
into that mechanism to get the chaning weights, but I only ran into deadends. I tried
using TensorFlow&amp;rsquo;s &amp;ldquo;eager execution&amp;rdquo; mode, but I was not able to get any of my Keras-based
models to work.&lt;/p&gt;

&lt;p&gt;It turns out the &lt;code&gt;tf.keras.Model&lt;/code&gt; exposes a method called &lt;code&gt;get_weights()&lt;/code&gt;. This
returns a Python array containing the weights and biases of the model. The
solution seems so easy in retrospect. Below is a demo of visualizing weights of
a very simple neural network.&lt;/p&gt;

&lt;h2 id=&#34;getting-model-parameters-during-training&#34;&gt;Getting Model Parameters During Training&lt;/h2&gt;

&lt;p&gt;Defined as a user story:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;As a TensorFlow programmer&lt;/li&gt;
&lt;li&gt;I want the ability to read a model&amp;rsquo;s parameters during training&lt;/li&gt;
&lt;li&gt;So that I can visualize them&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s create a very simple model with &lt;code&gt;tf.keras&lt;/code&gt;. It will consist of a single
neuron on a single layer. It will have two inputs.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re going to train the model to change its weights to &lt;code&gt;[1.0, 1.0]&lt;/code&gt;, so that
the neuron becomes equivalent to its activation function.&lt;/p&gt;

&lt;p&gt;First, import the necessary dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tensorflow as tf
from tensorflow import keras
import numpy as np
import matplotlib.pyplot as plt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Sequential: https://www.tensorflow.org/api_docs/python/tf/keras/models/Sequential
model = keras.Sequential([
    keras.layers.Dense(1, input_shape=(2,), activation=&#39;tanh&#39;)
])

learning_rate = 0.5
optimizer = tf.train.GradientDescentOptimizer(learning_rate)
model.compile(optimizer=optimizer,
              loss=&#39;mean_squared_error&#39;,
              metrics=[&#39;accuracy&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a single-neuron network, we need an activation function that is completely
differentiatiable. In other words, the graph of the function shouldn&amp;rsquo;t have any
horizontal lines or vertical lines or gaps in it. Otherwise, it could fail
to improve during training, depending on where the weights start off. &lt;code&gt;tanh&lt;/code&gt;
fits the bill.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/moxicon-public/blog/tensorflow-visualizing-weights/tanh-function.png&#34; alt=&#34;tanh function&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Generate the training data and corresponding labels:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# This function is used to generate training labels
# We need to match neuron&#39;s activation function
def tanh(x):
    x_sum = np.sum(x)
    return np.tanh(x_sum)

train_data = np.random.random((500, 2))
train_labels = np.array(list(map(tanh, train_data)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see how the model performs before training:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;test_data = np.random.random((10, 2))
test_labels = np.array(list(map(tanh, test_data)))

test_loss, _ = model.evaluate(test_data, test_labels)
print(&#39;loss:&#39;, test_loss)
# loss: 0.19740669429302216
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not great, eh? That&amp;rsquo;s what we expect for an untrained network.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how we record the weights during training:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Records the weights throughout the training process
weights_history = []

# A custom callback
# https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/Callback
class MyCallback(keras.callbacks.Callback):
    def on_batch_end(self, batch, logs):
        weights, _biases = model.get_weights()
        w1, w2 = weights
        weights = [w1[0], w2[0]]
        print(&#39;on_batch_end() model.weights:&#39;, weights)
        weights_history.append(weights)


callback = MyCallback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create a custom callback that inherits from &lt;code&gt;keras.callbacks.Callback&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When we call fit() to train the model, we pass in the callback:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# fit(): https://www.tensorflow.org/api_docs/python/tf/keras/models/Sequential#fit
model.fit(train_data, train_labels, epochs=10,
          verbose=False, callbacks=[callback])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watching the output, you&amp;rsquo;ll see updated weights at the end of each training batch.
They should approach &lt;code&gt;1.0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, &lt;code&gt;weights_history&lt;/code&gt; will have the historical weights.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s see how well the model performs, after training:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;test_loss, _ = model.evaluate(test_data, test_labels)
print(&#39;loss:&#39;, test_loss)
# loss: 0.00015836639795452356
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As loss of &lt;code&gt;0.0002&lt;/code&gt; is much better than &lt;code&gt;0.2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s plot the historical weight values during training:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(1, figsize=(6, 3))
plt.plot(weights_history)
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test 1:
&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/moxicon-public/blog/tensorflow-visualizing-weights/two-weights-training-1.png&#34; alt=&#34;weights during training 1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Test 2:
&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/moxicon-public/blog/tensorflow-visualizing-weights/two-weights-training-3.png&#34; alt=&#34;weights during training 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s it. We&amp;rsquo;ve successfully visualized neuron weights during training.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>TensorFlow on MacOS</title>
			<link>http://www.moxleystratton.com/tensorflow-macos/</link>
			<pubDate>Mon, 26 Nov 2018 03:06:44 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/tensorflow-macos/</guid>
			<description>&lt;p&gt;I was very excited to start running TensorFlow Python programs on my Mac.&lt;/p&gt;

&lt;p&gt;I installed it using PIP, using the instructions provided by &lt;a href=&#34;https://www.tensorflow.org/&#34;&gt;TensorFlow.org&lt;/a&gt;. On running my first TensorFlow program, the first thing it output was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2018-11-25 19:13:07.524017: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This didn&amp;rsquo;t look good, it turned out it&amp;rsquo;s just a warning. My program worked, but wasn&amp;rsquo;t running
as fast as it could. I don&amp;rsquo;t want to be hobbled by an inferior version of TensorFlow. I want the
optimized version!&lt;/p&gt;

&lt;p&gt;After some investigation, the way to resolve the warning is to compile TensorFlow from source:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tensorflow.org/install/source&#34;&gt;https://www.tensorflow.org/install/source&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When installing from source, the installer will prompt you for options. To keep things simple and maximize
the chance of success, use the default values provided.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Atom Editor Setup for Elixir</title>
			<link>http://www.moxleystratton.com/atom-elixir-setup/</link>
			<pubDate>Sat, 06 Oct 2018 10:02:41 PDT</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/atom-elixir-setup/</guid>
			<description>

&lt;p&gt;When working with Elixir, I want the following support from my editor:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Elixir syntax highlighting&lt;/li&gt;
&lt;li&gt;Compiler errors and warnings displayed while I&amp;rsquo;m editing Elixir code&lt;/li&gt;
&lt;li&gt;Automatic Elixir code formatting&lt;/li&gt;
&lt;li&gt;Automatic &lt;a href=&#34;http://hex.pm/packages/dialyxer&#34;&gt;Dialyzer&lt;/a&gt; checking and reporting when I save an Elixir code file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are the following plugins that provide those features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;language-elixir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ide-elixir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;atom-elixir-formatter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;linter-elixir-credo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before installing any of these packages, read their README pages carefully.&lt;/p&gt;

&lt;h2 id=&#34;language-elixir&#34;&gt;language-elixir&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/language-elixir&#34;&gt;https://atom.io/packages/language-elixir&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is the minimal package you want to use when developing Elixir code.
It provides code syntax highlighting.&lt;/p&gt;

&lt;h2 id=&#34;ide-elixir&#34;&gt;ide-elixir&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/ide-elixir&#34;&gt;https://atom.io/packages/ide-elixir&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The most value I get out of IDE Elixir is the feedback it gives from the Elixir
compiler, and from &lt;a href=&#34;http://hex.pm/packages/dialyxer&#34;&gt;Dialyzer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t care so much about the Dialyzer support, and you want something
more lightweight, I recommend &lt;a
href=&#34;https://atom.io/packages/linter-elixirc&#34;&gt;&lt;code&gt;linter-elixirc&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;atom-elixir-formatter&#34;&gt;atom-elixir-formatter&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/atom-elixir-formatter&#34;&gt;https://atom.io/packages/atom-elixir-formatter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This package formats Elixir code with the Elixir Formatter, which is built into
Elixir 1.6 and up. One side utility of this package is that it allows you to
paste in large data structures from test output into your test or fixtures, then
easily format the resulting code.&lt;/p&gt;

&lt;h2 id=&#34;linter-elixir-credo&#34;&gt;linter-elixir-credo&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/linter-elixir-credo&#34;&gt;https://atom.io/packages/linter-elixir-credo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This package integrates with Credo to report into code style and consistency.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Elixir Abstract Syntax</title>
			<link>http://www.moxleystratton.com/elixir-abstract-syntax/</link>
			<pubDate>Thu, 28 Dec 2017 10:02:41 -0700</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/elixir-abstract-syntax/</guid>
			<description>

&lt;p&gt;As developers know, program source code is represented as lines of text.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;Abstract Syntax Tree
(AST)&lt;/a&gt; is the representation
of the source code as a hierarchical data graph, specifically a tree structure.
With an AST, much of the difficult work parsing the original source code has
been performed, and the syntax can be introspected programatically.&lt;/p&gt;

&lt;p&gt;Similar to an AST, the &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_semantic_graph&#34;&gt;Abstract Semantic Graph (ASG)&lt;/a&gt; is a graph of the
semantic representation of the source code. The ASG goes one step further than
the AST by representing semantic information.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;When Erlang or Elixir source files are compiled, each module is converted to an
Abstract Semantic Graph and saved to a file. This file is called a BEAM file,
and it has a &lt;code&gt;.beam&lt;/code&gt; extension.&lt;/p&gt;

&lt;p&gt;Elixir provides a way to extract either the AST or ASG from source code. This
information is used by tools such as Formatter and Dialyzer for the benefit of
developers.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll walk through two techniques for extracting information from program code.&lt;/p&gt;

&lt;h3 id=&#34;the-elixir-ast&#34;&gt;The Elixir AST&lt;/h3&gt;

&lt;p&gt;The function &lt;code&gt;Code.string_to_quoted!/1&lt;/code&gt; converts Elixir source code into Elixir Abstract
Syntax Tree (AST).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; Code.string_to_quoted!(&amp;quot;2 + 3&amp;quot;)
{:+, [line: 1], [2, 3]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;string_to_quoted!/1&lt;/code&gt; (and its sibling &lt;code&gt;string_to_quoted/1&lt;/code&gt;) know that the
above bit of source code is an operation on two operands. It represents the
plus sign as an atom (&lt;code&gt;:+&lt;/code&gt;), and it represents the two operands as a list
(&lt;code&gt;[2, 3]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The Elixir AST typically contains three-element tuples like the one above. The
first element is an operation or data type. The second element is metadata about
the operation (e.g., source code line number), and the third element is the
arguments of the operation, or in the case of a data type, the data.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try an example on a function call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; Code.string_to_quoted!(&amp;quot;f()&amp;quot;)
{:f, [line: 1], []}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above represents a function call with an operand &lt;code&gt;:f&lt;/code&gt;. In actuality, the AST
is not sure it&amp;rsquo;s actually a function call. It just knows that the expression
is &amp;ldquo;call-like&amp;rdquo;, that it takes zero arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; Code.string_to_quoted!(&amp;quot;v&amp;quot;)
{:v, [line: 1], nil}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the AST gives &lt;code&gt;nil&lt;/code&gt; to the arguments list, meaning arguments don&amp;rsquo;t apply.
The AST representation does&amp;rsquo;t actually know whether it&amp;rsquo;s a call or a variable.
In Elixir parentheses are optional for a function call, so it could be either.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll do one more:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; Code.string_to_quoted!(&amp;quot;%{a: \&amp;quot;a\&amp;quot;}&amp;quot;)
{:%{}, [line: 1], [a: &amp;quot;a&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above shows what the AST looks like for a map literal.&lt;/p&gt;

&lt;h2 id=&#34;the-beam-file&#34;&gt;The BEAM File&lt;/h2&gt;

&lt;p&gt;When Elixir (or Erlang) compiles a module, it creates a &lt;code&gt;.beam&lt;/code&gt; file that
stores the compiled module. If code is compiled using &lt;code&gt;mix&lt;/code&gt;, the &lt;code&gt;.beam&lt;/code&gt; files
can be found in &lt;code&gt;_build/**/lib/**/ebin/*.beam&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.beam&lt;/code&gt; file can be created more directly, using &lt;code&gt;elixirc&lt;/code&gt;.
This puts the &lt;code&gt;.beam&lt;/code&gt; file in the current directory. We will
use &lt;code&gt;elixirc&lt;/code&gt; for the purposes of this article.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start with a sample module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule MyModule do
  def addition do
    2 + 3
  end

  def an_atom do
    :hello
  end

  def a_call do
    value = addition() + 1
    value + 4
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the above file to &lt;code&gt;my_module.ex&lt;/code&gt;, then run the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ elixirc my_module.ex
$ file Elixir.MyModule.beam
Elixir.MyModule.beam: Erlang BEAM file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Erlang provides the &lt;code&gt;beam_lib&lt;/code&gt; library and its &lt;code&gt;chunks/2&lt;/code&gt; function for reading
the &lt;code&gt;.beam&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; :beam_lib.chunks(&#39;Elixir.MyModule.beam&#39;, [:abstract_code])
{:ok, {MyModule, [
         abstract_code: {:raw_abstract_v1, [
                           {:attribute, 1, :file, {&#39;my_module.ex&#39;, 1}},
                           {:attribute, 1, :module, MyModule},
                           {:attribute, 1, :compile, :no_auto_import},
                           {:attribute, 1, :export, [
                              __info__: 1,
                              a_call: 0,
                              addition: 0,
                              an_atom: 0
                            ]},
                           ...
                           ]}]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first argument to &lt;code&gt;:beam_lib.chunks/2&lt;/code&gt; is the &lt;code&gt;.beam&lt;/code&gt; file path. Note the
single quotes; it&amp;rsquo;s a &lt;em&gt;charlist&lt;/em&gt;, not a string.&lt;/p&gt;

&lt;p&gt;The second argument is a list of &amp;ldquo;chunk types&amp;rdquo; to extract from the &lt;code&gt;.beam&lt;/code&gt; file.
The full list of available chunk types can be found in the &lt;a href=&#34;https://github.com/erlang/otp/blob/master/lib/stdlib/src/beam_lib.erl#L68-L73&#34;&gt;Erlang Source Code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The bulk of the return data is a list of tuples. Some of the tuples contain
the atom &lt;code&gt;:attributes&lt;/code&gt; as the first element, and the others have &lt;code&gt;:function&lt;/code&gt; as
the first element.&lt;/p&gt;

&lt;p&gt;The tuples having &lt;code&gt;:function&lt;/code&gt; represent the functions of the module. The third
element in the tuple is the function name.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice a large function called
&lt;code&gt;:__info__&lt;/code&gt; that is automatically added to all Elixir modules.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;{:function, 0, :__info__, 1, [...]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last three
functions are the ones defined in the module&amp;rsquo;s source code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;[
  ...
  {:function, 10, :a_call, 0, [...]},
  {:function, 2, :addition, 0, [...]},
  {:function, 6, :an_atom, 0, [...]}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Digging into the &lt;code&gt;:addition&lt;/code&gt; function representation, we can see the semantic
representation of the simple addition operation, &lt;code&gt;2 + 3&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;{
  :op,
  3,
  :+,
  {:integer, 0, 2},
  {:integer, 0, 3}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the goal is to get the list of functions defined by the module, a small filter and map is all it takes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;{:ok, {module, [abstract_code: {:raw_abstract_v1, attributes}]}} =
  :beam_lib.chunks(&#39;Elixir.MyModule.beam&#39;, [:abstract_code])

attributes
|&amp;gt; Enum.filter(&amp;amp;(elem(&amp;amp;1, 0) == :function))
|&amp;gt; Enum.map(fn {_, _, name, arity, _} -&amp;gt; {name, arity} end)

# Returns: [__info__: 1, bar: 0, foo: 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve learned how to introspect Elixir source code by extracting the AST and
ASG. It is my hope that this information will help you build the next great
developer tool for Elixir.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Install Redis on macOS with Homebrew</title>
			<link>http://www.moxleystratton.com/install-redis-on-macos-with-homebrew/</link>
			<pubDate>Wed, 09 Aug 2017 10:02:41 PDT</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/install-redis-on-macos-with-homebrew/</guid>
			<description>

&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install redis
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upgrade&#34;&gt;Upgrade&lt;/h2&gt;

&lt;p&gt;If Redis is already installed, you might want to upgrade:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew upgrade redis
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;verify&#34;&gt;Verify&lt;/h2&gt;

&lt;p&gt;Check to see if Redis is already running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it&amp;rsquo;s already running, you can probably stop here.&lt;/p&gt;

&lt;h2 id=&#34;launch-on-system-boot&#34;&gt;Launch on System Boot&lt;/h2&gt;

&lt;p&gt;Check to see if it is already set up to launch on boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l ~/Library/LaunchAgents | grep -i redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make it launch on boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;management&#34;&gt;Management&lt;/h2&gt;

&lt;p&gt;Redis can be started and stopped with these two commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew services start redis
brew services stop redis
&lt;/code&gt;&lt;/pre&gt;
</description>
		</item>
		
		<item>
			<title>Install Elixir on macOS Using ASDF</title>
			<link>http://www.moxleystratton.com/install-elixir-on-macos-using-asdf/</link>
			<pubDate>Wed, 09 Aug 2017 09:45:01 PDT</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/install-elixir-on-macos-using-asdf/</guid>
			<description>

&lt;h2 id=&#34;install-asdf&#34;&gt;Install asdf&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.3.0
echo -e &#39;\n. $HOME/.asdf/asdf.sh&#39; &amp;gt;&amp;gt; ~/.bash_profile
echo -e &#39;\n. $HOME/.asdf/completions/asdf.bash&#39; &amp;gt;&amp;gt; ~/.bash_profile
. ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-erlang-and-elixir-plugins&#34;&gt;Install Erlang and Elixir Plugins&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;asdf plugin-add erlang https://github.com/asdf-vm/asdf-erlang.git
asdf plugin-add elixir https://github.com/asdf-vm/asdf-elixir.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;uninstall-erlang-and-elixir-managed-by-brew&#34;&gt;Uninstall Erlang and Elixir managed by Brew&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew uninstall --force erlang
brew uninstall --force elixir
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-erlang&#34;&gt;Install Erlang&lt;/h2&gt;

&lt;p&gt;Check what versions of Erlang are available:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asdf list-all erlang
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install and Use Erlang:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asdf install erlang 19.3
asdf global erlang 19.3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-elixir&#34;&gt;Install Elixir&lt;/h2&gt;

&lt;p&gt;Check what versions of Elixir are available:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asdf list-all elixir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install and Use Elixir:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asdf install elixir 1.4.4
asdf global elixir 1.4.4
&lt;/code&gt;&lt;/pre&gt;
</description>
		</item>
		
		<item>
			<title>Low-Level ActiveRecord</title>
			<link>http://www.moxleystratton.com/low-level-activerecord/</link>
			<pubDate>Sun, 27 Sep 2015 10:58:40 PDT</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/low-level-activerecord/</guid>
			<description>

&lt;p&gt;With many Rails projects, there is occasionally a need to bypass the normal
ActiveRecord API, and get closer to the low-level SQL API. Here are a few
useful methods that bypass the confines of everyday ActiveRecord.&lt;/p&gt;

&lt;h3 id=&#34;find-by-sql&#34;&gt;#find_by_sql&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;users = User.find_by_sql(&amp;quot;SELECT * FROM users WHERE id = 1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns model instances for the given SQL string.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#find_by_sql&lt;/code&gt; also accepts parametrized values, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;users = User.find_by_sql([&amp;quot;SELECT * FROM users WHERE id = ?&amp;quot;, 1])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;select-all&#34;&gt;#select_all&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;users = ActiveRecord::Base.connection.select_all(&amp;quot;
  SELECT id, first_name, created_at
  FROM users
  WHERE id = 1&amp;quot;)

users[0]
{
  &amp;quot;id&amp;quot;         =&amp;gt; 202,
  &amp;quot;first_name&amp;quot; =&amp;gt; &amp;quot;Trystan&amp;quot;,
  &amp;quot;created_at&amp;quot; =&amp;gt; &amp;quot;2015-09-05 15:44:51.597326&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns an array-like object of type &lt;code&gt;ActiveRecord::Result&lt;/code&gt;. Each item in
the collection is a &lt;code&gt;Hash&lt;/code&gt; representing a row in the results.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;ActiveRecord::Result&lt;/code&gt; contains information about the table and its columns.
It knows how to convert column values to &lt;em&gt;some of&lt;/em&gt; their corresponding Ruby
types.&lt;/p&gt;

&lt;h3 id=&#34;execute&#34;&gt;#execute&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;users = ActiveRecord::Base.connection.execute(&amp;quot;SELECT id, first_name, created_at FROM users WHERE id=1&amp;quot;)

users[0]
{
  &amp;quot;id&amp;quot;         =&amp;gt; &amp;quot;1&amp;quot;,
  &amp;quot;first_name&amp;quot; =&amp;gt; &amp;quot;Trystan&amp;quot;,
  &amp;quot;created_at&amp;quot; =&amp;gt; &amp;quot;2015-09-05 15:44:51.597326&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns an array-like object that is specific on the database driver. For
PostgreSQL, this will be a &lt;code&gt;PG::Result&lt;/code&gt;. Each item in the collection is a
&lt;code&gt;Hash&lt;/code&gt;. The values of the Hash are strings and nils. No conversion is performed
to convert the values to the appropriate Ruby type, other than NULL to nil.&lt;/p&gt;

&lt;h3 id=&#34;quote&#34;&gt;#quote&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;select_all&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt; methods have no built-in mechanism for escaping
values for the SQL statement.&lt;/p&gt;

&lt;p&gt;Something like this is bad practice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;users = ActiveRecord::Base.connection.select_all(&amp;quot;
  SELECT * FROM users WHERE email=&#39;#{email}&#39;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we&amp;rsquo;re not sure what is in &lt;code&gt;email&lt;/code&gt;. It could have an SQL injection
attack, or it could just have unexpected characters that will break
the query. To cover these
cases, ActiveRecord provides &lt;code&gt;#quote&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;conn = ActiveRecord::Base.connection
users = conn.select_all(&amp;quot;
  SELECT * FROM users WHERE email=#{conn.quote(email)}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the SQL statement does not have single quote marks around the email.
&lt;code&gt;#quote&lt;/code&gt; does that automatically.&lt;/p&gt;

&lt;h3 id=&#34;sanitize-sql-array&#34;&gt;#sanitize_sql_array&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;#quote&lt;/code&gt; can get unwieldy as more and more values need to be escaped.
There is a private method called &lt;code&gt;#sanitize_sql_array&lt;/code&gt; that brings back the
parameterized escape mechanism that is present in ActiveRecord&amp;rsquo;s higher-level
API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sql = ActiveRecord::Base.send(:sanitize_sql_array,
  [&amp;quot;SELECT * FROM users WHERE email=?&amp;quot;, email])

users = ActiveRecord::Base.connection.select_all(sql)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;connection-config&#34;&gt;#connection_config&lt;/h3&gt;

&lt;p&gt;Sometimes you need to introspect the database connection details. Maybe you have an external utility that performs bulk operations against the database, and
it bypasses ActiveRecord entirely.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config = Rails.application.config.database_configuration

{
  &amp;quot;common&amp;quot; =&amp;gt; {
    &amp;quot;adapter&amp;quot;           =&amp;gt; &amp;quot;postgres&amp;quot;,
    &amp;quot;encoding&amp;quot;          =&amp;gt; &amp;quot;utf8&amp;quot;,
    &amp;quot;postgis_extension&amp;quot; =&amp;gt; true,
    &amp;quot;username&amp;quot;          =&amp;gt; &amp;quot;user&amp;quot;,
    &amp;quot;password&amp;quot;          =&amp;gt; &amp;quot;password&amp;quot;,
    &amp;quot;host&amp;quot;              =&amp;gt; &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;port&amp;quot;              =&amp;gt; 5432
  },
  &amp;quot;development&amp;quot; =&amp;gt; {
    &amp;quot;adapter&amp;quot;           =&amp;gt; &amp;quot;postgres&amp;quot;,
    &amp;quot;encoding&amp;quot;          =&amp;gt; &amp;quot;utf8&amp;quot;,
    &amp;quot;postgis_extension&amp;quot; =&amp;gt; true,
    &amp;quot;username&amp;quot;          =&amp;gt; &amp;quot;user&amp;quot;,
    &amp;quot;password&amp;quot;          =&amp;gt; &amp;quot;password&amp;quot;,
    &amp;quot;host&amp;quot;              =&amp;gt; &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;port&amp;quot;              =&amp;gt; 5432,
    &amp;quot;database&amp;quot;          =&amp;gt; &amp;quot;database_development&amp;quot;    
  },
  &amp;quot;production&amp;quot; =&amp;gt; {
    &amp;quot;adapter&amp;quot;           =&amp;gt; &amp;quot;postgres&amp;quot;,
    &amp;quot;encoding&amp;quot;          =&amp;gt; &amp;quot;utf8&amp;quot;,
    &amp;quot;postgis_extension&amp;quot; =&amp;gt; true,
    &amp;quot;username&amp;quot;          =&amp;gt; &amp;quot;user&amp;quot;,
    &amp;quot;password&amp;quot;          =&amp;gt; &amp;quot;password&amp;quot;,
    &amp;quot;host&amp;quot;              =&amp;gt; &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;port&amp;quot;              =&amp;gt; 5432,
    &amp;quot;database&amp;quot;          =&amp;gt; &amp;quot;database_production&amp;quot;    
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;with-connection&#34;&gt;#with_connection&lt;/h2&gt;

&lt;p&gt;Using a database connection and not returning is like opening a file and not
closing it. It can lead to connection leaks in some contexts.
ActiveRecord provides a block-style pattern for using a database connection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ActiveRecord::Base.connection_pool.with_connection do |conn|
  users = conn.select_all(&amp;quot;
    SELECT * FROM users WHERE email=#{conn.quote(email)}&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;structure-load&#34;&gt;#structure_load&lt;/h2&gt;

&lt;p&gt;For times when you need to load a bunch of SQL statements from a file,
ActiveRecord provides &lt;code&gt;#structure_load&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config = Rails.application.config.database_configuration[&#39;development&#39;]
sql_file = &amp;quot;tmp/foo.sql&amp;quot;
ActiveRecord::Tasks::DatabaseTasks.structure_load(config, sql_file)
&lt;/code&gt;&lt;/pre&gt;
</description>
		</item>
		
		<item>
			<title>Finding the source for a given Rails web page</title>
			<link>http://www.moxleystratton.com/finding-the-source-for-a-given-rails-web-page/</link>
			<pubDate>Thu, 29 May 2014 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/finding-the-source-for-a-given-rails-web-page/</guid>
			<description>

&lt;p&gt;These tips may help those of you who are relatively new to Rails, or maybe even if you&amp;rsquo;re not.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;common-tips-and-tricks&#34;&gt;Common tips and tricks&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Look at the URL path (e.g. &lt;code&gt;/users/100685/edit&lt;/code&gt;).
Can the action and main view file be determined from CRUD/REST conventions?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/:model/edit&lt;/code&gt; -&amp;gt; edit.html.slim&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/:model/1234&lt;/code&gt; -&amp;gt; show.html.slim&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/:model/new&lt;/code&gt; -&amp;gt; new.html.slim&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/:model&lt;/code&gt; -&amp;gt; index.html.slim&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Look up the path in routes.rb, or even more useful, run &lt;code&gt;rake routes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;finding-a-controller-and-action-responsible-for-a-given-page&#34;&gt;Finding a controller and action responsible for a given page&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;In development go to your server&amp;rsquo;s output, and clear the screen (&lt;code&gt;Ctrl+L&lt;/code&gt;,
for Linux, &lt;code&gt;Cmd-K&lt;/code&gt; for OS X)&lt;/li&gt;
&lt;li&gt;Refresh the web page&lt;/li&gt;
&lt;li&gt;Back to the server&amp;rsquo;s output, scroll to the top of the output. About the second
line of non-blank log output, you should see something like:
&lt;code&gt;Processing by UserseController#edit as HTML&lt;/code&gt;. That&amp;rsquo;s the
controller (&lt;code&gt;UsersController&lt;/code&gt;) and action (&lt;code&gt;edit&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;finding-a-view-file-for-a-given-page&#34;&gt;Finding a view file for a given page&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;If in development, look at the server log. If it is too noisy, use
&lt;code&gt;tail -f log/development | grep Rendered&lt;/code&gt; to cut out the noise.&lt;/li&gt;
&lt;li&gt;If in development, add the &lt;code&gt;rails_view_annotator&lt;/code&gt; gem to your Gemfile,
and look at the DOM or HTML source. It should have HTML comments identifying
the view partials responsible for their generated HTML.&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		
		<item>
			<title>Considering a switch to the Atom Text Editor?</title>
			<link>http://www.moxleystratton.com/considering-a-switch-to-the-atom-text-editor/</link>
			<pubDate>Sun, 16 Mar 2014 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/considering-a-switch-to-the-atom-text-editor/</guid>
			<description>

&lt;p&gt;You&amp;rsquo;ve probably heard of &lt;a href=&#34;http://atom.io/&#34;&gt;Atom, Github&amp;rsquo;s new text editor&lt;/a&gt;. Read
these checklists to help you decide whether it&amp;rsquo;s an editor worth switching to.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;general-pros&#34;&gt;General Pros&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Open Source&lt;/li&gt;
&lt;li&gt;High-quality extension and enhancement infrastructure&lt;/li&gt;
&lt;li&gt;View is programmable using good old HTML DOM and CSS&lt;/li&gt;
&lt;li&gt;Well-known API model (NodeJS)&lt;/li&gt;
&lt;li&gt;Built-in Github integration&lt;/li&gt;
&lt;li&gt;Built-in, light Git integration&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=VGUemwCaBR0&amp;amp;amp;feature=youtu.be&#34;&gt;Realtime Markdown preview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Seamlessly tracks external file renames while the file is open&lt;/li&gt;
&lt;li&gt;Browse archive files, like zip or tar.gz, like Emacs does.&lt;/li&gt;
&lt;li&gt;UI and editing features basically a clone of Sublime Text&lt;/li&gt;
&lt;li&gt;Free, while in Beta.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;general-cons&#34;&gt;General Cons&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;In Beta. Some rough UX details.&lt;/li&gt;
&lt;li&gt;No keyboard macros&lt;/li&gt;
&lt;li&gt;No command documentation&lt;/li&gt;
&lt;li&gt;Difficult to discover available commands&lt;/li&gt;
&lt;li&gt;Currently only works on OS X (Windows and Linux planned)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;for-sublime-users&#34;&gt;For Sublime Users&lt;/h2&gt;

&lt;h3 id=&#34;pros&#34;&gt;Pros&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Package manager is built in&lt;/li&gt;
&lt;li&gt;Deep customization API&lt;/li&gt;
&lt;li&gt;Fine-grained commands&lt;/li&gt;
&lt;li&gt;Complete pane splitting and pane navigation&lt;/li&gt;
&lt;li&gt;Smarter indentation of pasted text&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cons&#34;&gt;Cons&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2-3x slower, 2-3x more memory than ST3 (realistically, it&amp;rsquo;s not as bad as it sounds)&lt;/li&gt;
&lt;li&gt;No &amp;ldquo;Jump Back&amp;rdquo; feature, as found in ST3&lt;/li&gt;
&lt;li&gt;No auto-highlighting matching strings of selected string&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t open file in existing window, unless it lives within the window&amp;rsquo;s directory&lt;/li&gt;
&lt;li&gt;Missing key bindings for many search &amp;amp; replace operations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;for-vim-and-emacs-users&#34;&gt;For Vim and Emacs Users&lt;/h2&gt;

&lt;h3 id=&#34;pros-1&#34;&gt;Pros&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Modern Application and UI, contemporary key bindings&lt;/li&gt;
&lt;li&gt;Easy to learn&lt;/li&gt;
&lt;li&gt;Built in Package manager, and standard package formats&lt;/li&gt;
&lt;li&gt;View is good old HTML DOM, CSS&lt;/li&gt;
&lt;li&gt;CoffeeScript is arguably better than eLisp and Vimscript&lt;/li&gt;
&lt;li&gt;Editor API reaches deep into the editor&lt;/li&gt;
&lt;li&gt;Project-wide fuzzy file finder, built in, fuss-free&lt;/li&gt;
&lt;li&gt;Buffer-wide fuzzy symbol finder, built in, fuss-free&lt;/li&gt;
&lt;li&gt;Project-wide string search&lt;/li&gt;
&lt;li&gt;Large number of homerow-close key bindings (many of them are Emacs compatible)&lt;/li&gt;
&lt;li&gt;Pane splitting on par with Vim and Emacs&lt;/li&gt;
&lt;li&gt;Multi selections&lt;/li&gt;
&lt;li&gt;Code Snippets&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cons-1&#34;&gt;Cons&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Editor API doesn&amp;rsquo;t go as deep as Emacs. Lacks rich callback API that Emacs has.&lt;/li&gt;
&lt;li&gt;No cursor history, so no command for going back to the last location without using bookmarks&lt;/li&gt;
&lt;li&gt;No cursor navigation around, or editing operations on, symbol definitions (e.g., methods)&lt;/li&gt;
&lt;li&gt;Unlike Emacs, no built-in shell console (package under development)&lt;/li&gt;
&lt;li&gt;Keyboard navigation of file tree is cumbersome, but will likely improve over time.&lt;/li&gt;
&lt;li&gt;Missing a lot of the cool text navigation and editing commands available to Vim and Emacs&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		
		<item>
			<title>Simple Cellular Automata</title>
			<link>http://www.moxleystratton.com/simple-cellular-automata/</link>
			<pubDate>Sat, 01 Dec 2012 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/simple-cellular-automata/</guid>
			<description>&lt;p&gt;I released a very simple cellular automata explorer. &lt;a href=&#34;http://www.moxleystratton.com/cellauto/cellauto.html&#34;&gt;Try it out here&lt;/a&gt;.
See the &lt;a href=&#34;https://github.com/moxley/cellauto&#34;&gt;Github page&lt;/a&gt; for more information.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Ten Secret Key Bindings from OS X</title>
			<link>http://www.moxleystratton.com/ten-secret-key-bindings/</link>
			<pubDate>Fri, 11 May 2012 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/ten-secret-key-bindings/</guid>
			<description>&lt;p&gt;Did you know that when using these applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Any application on OS X, except Vim and MS products&lt;/li&gt;
&lt;li&gt;Bash, or any console program with Readline support&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;p&gt;These key bindings are available:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Control-A - Move to beginning of line&lt;/li&gt;
&lt;li&gt;Control-E - Move to end of line&lt;/li&gt;
&lt;li&gt;Control-F - Move forward one column&lt;/li&gt;
&lt;li&gt;Control-B - Move backward one column&lt;/li&gt;
&lt;li&gt;Control-N - Move to next line&lt;/li&gt;
&lt;li&gt;Control-P - Move to previous line&lt;/li&gt;
&lt;li&gt;Control-D - Delete next character&lt;/li&gt;
&lt;li&gt;Control-H - Delete previous character&lt;/li&gt;
&lt;li&gt;Control-K - Delete from cursor to end of line&lt;/li&gt;
&lt;li&gt;Control-Y - Paste what was deleted with Control-K&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It seems silly, but the thing I love the most about OS X is the ubiquity of these key bindings. Any text editing, from writing a blog post in Chrome, to writing code in TextMate is immensely sweeter with the availability of the above key bindings. One need not leave the keyboard&amp;rsquo;s home row to do much of anything when they&amp;rsquo;re available.&lt;/p&gt;

&lt;p&gt;Whether you use Emacs or Vim or another text editor, learn to use key bindings that allow you to keep your fingers close to the home row. Your text editing will be faster an more efficient.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Injection</title>
			<link>http://www.moxleystratton.com/injection/</link>
			<pubDate>Fri, 13 Apr 2012 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/injection/</guid>
			<description>&lt;p&gt;Within the world of application development, there is a conspiracy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$sql = &amp;quot;SELECT * FROM users WHERE username=&#39;&amp;quot; . $username . &amp;quot;&#39;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;What&amp;rsquo;s wrong with this code? The problem is that &lt;code&gt;$username&lt;/code&gt; needs to be escaped before it can be put into the SQL statement. If &lt;code&gt;$username&lt;/code&gt; contains single quotes, the SQL statement will do something you did not intend. If you already know this, stick around, there&amp;rsquo;s more to this story.&lt;/p&gt;

&lt;p&gt;Without escaping the data before it is added to the SQL, the code is vulnerable to Injection attack. Injection is the top security risk in applications, according to &lt;a href=&#34;https://www.owasp.org/index.php/Top_10_2010-Main&#34;&gt;OWASP&amp;rsquo;s Top 10 Security Risks&lt;/a&gt;&amp;gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the corrected code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$sql = &amp;quot;SELECT * FROM users WHERE username=&#39;&amp;quot; . mysql_real_escape_string($username) . &amp;quot;&#39;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the really long function name &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;? The long length is part of a conspiracy to discourage you from escaping injected data.&lt;/p&gt;

&lt;p&gt;If you work much with SQL, you may also know about parameterized SQL statements, which automatically escape the injected data, and they reduce the need to concatenate bits of SQL together.&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s pull out the essential parts from the PHP example. The &lt;code&gt;$username&lt;/code&gt; value is &lt;em&gt;data&lt;/em&gt;. It&amp;rsquo;s being &lt;em&gt;injected&lt;/em&gt; into the source code of a computer &lt;em&gt;language&lt;/em&gt; called SQL. Notice these three keywords:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;data&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;injection&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;language&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Look for these words as we move on.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; value=&amp;quot;&amp;lt;?php echo $username ?&amp;gt;&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The situation is the same as before, but now the language is HTML. We&amp;rsquo;re still &lt;em&gt;injecting&lt;/em&gt; some &lt;em&gt;data&lt;/em&gt;, &lt;code&gt;$username&lt;/code&gt;, into the &lt;em&gt;language&lt;/em&gt;. And like the first SQL example, &lt;code&gt;$username&lt;/code&gt; is not escaped.&lt;/p&gt;

&lt;p&gt;The security attack that leverages this defect is called Cross-Site Scripting (XSS). XSS is the number two security risk, according to &lt;a href=&#34;https://www.owasp.org/index.php/Top_10_2010-Main&#34;&gt;OWASP&amp;rsquo;s Top Ten list&lt;/a&gt;. XSS is actually just another case of Injection. The defect that causes these two vulnerabilities is the same kind of defect&amp;ndash; failing to escape data that is being injected into a language.&lt;/p&gt;

&lt;p&gt;What does PHP provide you to avert certain disaster?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;input
  name=&amp;quot;username&amp;quot;
  value=&amp;quot;&amp;lt;?php echo htmlspecialchars($username)?&amp;gt;&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case you weren&amp;rsquo;t thinking of it already, I just want to say, PHP is one &lt;em&gt;ugly&lt;/em&gt; language.&lt;/p&gt;

&lt;p&gt;With a name like &lt;code&gt;htmlspecialchars()&lt;/code&gt;, you might guess it was not intended to be used often. Actually, nine out of ten times it is perfectly appropriate to use &lt;code&gt;htmlspecialchars()&lt;/code&gt;. If the length of &lt;code&gt;htmlspecialchars()&lt;/code&gt; bothers you as much as it does me, I suggest writing your own shortcut:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
function h($str) {
  return htmlspecialchars($str);
}
?&amp;gt;
&amp;lt;input name=&amp;quot;username&amp;quot; value=&amp;quot;&amp;lt;?php echo h($username) ?&amp;gt;&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only when you really want to inject actual HTML would you not use &lt;code&gt;htmlspecialchars()&lt;/code&gt;. And when you do so, be sure the HTML is either trusted or sanitized.&lt;/p&gt;

&lt;p&gt;If you are ever in the position to choose a templating language, choose one that escapes injected data by default, because that&amp;rsquo;s what is needed 90% of the time. Yes, 90%. Think about it: how often do you inject HTML into HTML, compared to how often you inject plain old data? Not very often. Note that the top PHP templating languages &lt;em&gt;do not&lt;/em&gt; escape data by default. The default templating language for Rails 3&amp;ndash; ERB&amp;ndash; escapes data by default. Most of the JavaScript templating languages escape by default.&lt;/p&gt;

&lt;p&gt;Next, we&amp;rsquo;ll move on to JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;#notice&#39;).html(&#39;&#39; + message + &#39;&amp;lt;/p&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do you see the pattern? The &lt;em&gt;language&lt;/em&gt; is HTML, the &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;message&lt;/code&gt;. This time, it is JavaScript &lt;em&gt;injecting&lt;/em&gt; data into another language. Do you know what JavaScript gives us to escape &lt;code&gt;message&lt;/code&gt; for injecting it into HTML? Nothing. Absolutely nothing. What does jQuery give us for the task?&lt;/p&gt;

&lt;p&gt;Nothing.&lt;/p&gt;

&lt;p&gt;Yes, really. Escaping data for HTML seems like such an essential task for web programming, yet the designers of both JavaScript and jQuery have provided nothing for it. This is part of the conspiracy.&lt;/p&gt;

&lt;p&gt;With JavaScript, we must write our own function to escape data for HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Escape for HTML
function h(str) {
  if (typeof str == &#39;number&#39;) {
    return str;
  }
  else if (!str || !str.length) {
    return &#39;&#39;;
  }
  var i, c, out = &#39;&#39;,
    trans = {
      &#39;&amp;lt;&#39;: &#39;&amp;amp;lt;&#39;, &#39;&amp;gt;&#39;: &#39;&amp;amp;gt;&#39;,
      &#39;&amp;quot;&#39;: &#39;&amp;amp;quot;&#39;, &amp;quot;&#39;&amp;quot;: &#39;&amp;amp;#39;&#39;,
      &#39;&amp;amp;&#39;: &#39;&amp;amp;amp;&#39;
    };
  for (i = 0; i &amp;lt; str.length; i += 1) {
    c = str[i];
    out += trans[c] || c;
  }
  return out;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now ``message&amp;rdquo; can be escaped:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;#notice&#39;).html(&#39;&#39; + h(message) + &#39;&amp;lt;/p&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there you have it: three examples of injection, and three solutions for escaping data before injecting it into language code.&lt;/p&gt;

&lt;p&gt;Using a templating language that escapes by default is great, and so is using parameterized SQL statements. But don&amp;rsquo;t think that you don&amp;rsquo;t have to worry about escaping data again. If you work with multiple languages, you will eventually need to call upon an escape function.&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Clojure Tutorial for the Non-Lisp Programmer</title>
			<link>http://www.moxleystratton.com/clojure-tutorial-for-the-non-lisp-programmer/</link>
			<pubDate>Thu, 01 May 2008 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/clojure-tutorial-for-the-non-lisp-programmer/</guid>
			<description>

&lt;p&gt;I intend to keep this tutorial as accurate and up-to-date as possible. If you have any suggestions for changes, please leave a comment at the bottom of this page.&lt;/p&gt;

&lt;p&gt;Clojure is a functional lisp dialect that uses the Java Virtual Runtime as its platform. The language home page is at &lt;a href=&#34;http://clojure.org/&#34;&gt;http://clojure.org/&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#quick-comparison&#34;&gt;A Quick Comparison&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#install&#34;&gt;Installing Clojure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#atoms&#34;&gt;Atoms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vectors&#34;&gt;Vectors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lists&#34;&gt;Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#maps-sets&#34;&gt;Maps and Sets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#defs&#34;&gt;Defining Variables and Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#special-forms&#34;&gt;Special Forms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#looping-iterating&#34;&gt;Looping and Iterating&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sequences&#34;&gt;Sequences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#java-integration&#34;&gt;Java Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#libraries&#34;&gt;Using Libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#resources&#34;&gt;Additional Resources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;quick-comparison&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-quick-comparison&#34;&gt;A Quick Comparison&lt;/h2&gt;

&lt;p&gt;In C-like languages, a function call might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;do_something_with(value1, value2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Clojure, the same function call would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(do-something-with value1 value2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, Clojure&amp;rsquo;s syntax differs in these ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The opening parenthesis is to the left of the function name.&lt;/li&gt;
&lt;li&gt;There are no commas delimiting the function parameters.&lt;/li&gt;
&lt;li&gt;By convention, words in a function name are separated by dashes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There&amp;rsquo;s not a huge difference.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how adding two values might look in a C-like language:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;value1 + value2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And heres how it would look in Clojure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(+ value1 value2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C, the plus operator goes in between the two operands. In Clojure, the operator is always first, and there can be any number of operands. In this way, there is no syntactic difference between operators and function calls. They are the same. This is a thematic difference between Clojure and non-Lisp languages: Clojure is more simple.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;install&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;installing-clojure&#34;&gt;Installing Clojure&lt;/h2&gt;

&lt;p&gt;A fast and easy way to get started with Clojure is to download and run &lt;a href=&#34;https://github.com/arthuredelstein/clooj#readme&#34;&gt;Clooj&lt;/a&gt;. Clooj is an Integrated Development Environment for Clojure.&lt;/p&gt;

&lt;p&gt;As an alternative, the Clojure website provides &lt;a href=&#34;http://clojure.org/getting_started&#34;&gt;instructions for installing Clojure the traditional way&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The primary way of interacting with Clojure is through the REPL (Read-Evaluate-Print-Loop). The REPL Reads expressions that you give it, Evaluates the expressions, Prints the value that is the result, and Loops around for more input.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;atoms&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;atoms&#34;&gt;Atoms&lt;/h1&gt;

&lt;p&gt;There are two categories of Clojure expressions, &lt;em&gt;atoms&lt;/em&gt; and &lt;em&gt;lists&lt;/em&gt;. Atoms are like the primitive types in other languages. Lets use the &lt;span class=&#34;caps&#34;&gt;REPL&lt;/span&gt; to explore some atoms.&lt;/p&gt;

&lt;h3 id=&#34;numbers&#34;&gt;Numbers&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; 5
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number 5 is evaluated and the result is displayed.&lt;/p&gt;

&lt;h3 id=&#34;booleans&#34;&gt;Booleans&lt;/h3&gt;

&lt;p&gt;Heres another atom:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; true
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojure supports boolean &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; values, represented as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; respectively.&lt;/p&gt;

&lt;h3 id=&#34;nil&#34;&gt;Nil&lt;/h3&gt;

&lt;p&gt;Here is another important atom:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; nil
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is Clojures name for no-value, or null. It resolves to Javas &lt;code&gt;null&lt;/code&gt; value.&lt;/p&gt;

&lt;h3 id=&#34;strings&#34;&gt;Strings&lt;/h3&gt;

&lt;p&gt;Here is a Clojure string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; &amp;quot;Hello, world!&amp;quot;
&amp;quot;Hello, world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojure strings follow the same rules as Java strings, so for instance, &lt;code&gt;&amp;quot;\t&amp;quot;&lt;/code&gt; represents the ASCII &lt;code&gt;TAB&lt;/code&gt; character. The Java API is the primary way to make calculations on a string.&lt;/p&gt;

&lt;h3 id=&#34;symbols&#34;&gt;Symbols&lt;/h3&gt;

&lt;p&gt;Symbols are stand-in names for values. They&amp;rsquo;re sort of like what you would call a constant in other languages. Clojure doesn&amp;rsquo;t have variables. And unlike other languages, Clojure makes a distinction between a symbol and its value.&lt;/p&gt;

&lt;p&gt;When a symbol is evaluated, its value is returned:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; *file*
&amp;quot;NO_SOURCE_PATH&amp;quot;
user=&amp;gt; *compile-path*
&amp;quot;classes&amp;quot;
user=&amp;gt; *clojure-version*
{:major 1, :minor 3, :incremental 0, :qualifier nil}
user=&amp;gt; *command-line-args*
nil
user=&amp;gt; +
#&amp;lt;core$_PLUS_ clojure.core$_PLUS_@6d581e80&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above shows some of Clojure&amp;rsquo;s built-in symbols. By convention, built-in symbols begin and end with &amp;lsquo;*&amp;rsquo; if they bind to data. The last symbol shown &amp;ldquo;+&amp;rdquo; is a built-in function.&lt;/p&gt;

&lt;h3 id=&#34;keywords&#34;&gt;Keywords&lt;/h3&gt;

&lt;p&gt;Keywords are like symbols, except that they do not bind to an arbitrary value. They always bind to themselves. Keywords always start with a colon (&lt;code&gt;:&lt;/code&gt;). Here are some keywords:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; :a
:a
user=&amp;gt; :_123
:_123
user=&amp;gt; :KEY
:KEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;lists&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lists&#34;&gt;Lists&lt;/h2&gt;

&lt;p&gt;Near the beginning of the tutorial we saw a function call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;=&amp;gt; (+ 3 3 3)
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function calls use lists to define the call. Lists are comprised of an opening and closing parenthesis, and zero or more elements. Each element is separated by whitespace or commas.&lt;/p&gt;

&lt;p&gt;Lists can be both a data structure and a functional call form. When used as a function call, the first element of the lists is a function. Any remaining elements in the list are the function&amp;rsquo;s arguments.&lt;/p&gt;

&lt;p&gt;When a list is used to perform an operation, it is called a &lt;em&gt;form&lt;/em&gt;. The function element of the form is referred to as the &lt;em&gt;operator&lt;/em&gt;. Strictly, it isn&amp;rsquo;t always a function. There are three kinds of forms: &lt;em&gt;functions&lt;/em&gt;, &lt;em&gt;macros&lt;/em&gt;, and &lt;em&gt;special forms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Although the list can be used to perform operations, it can also be used to represent data. There is an important consequence of code and data sharing the same syntax: code can be manipulated as if it were data because it &lt;em&gt;is&lt;/em&gt; data.&lt;/p&gt;

&lt;p&gt;One way to use lists simply as data is to use Clojures built-in operation, &lt;code&gt;list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (list 1 2 3)
(1 2 3)
user=&amp;gt; (list a b c)
(a b c)
user=&amp;gt; (list &amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot;)
(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List items can be atoms, other lists, or other data structures that are part of Clojure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (list :foo (list 1 2 3) [4 5 6])
(:foo (1 2 3) [4 5 6])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojure also has a short-cut syntax for creating a list as data. Just prepend the list with a single-quote character:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; &#39;(1 2 3)
(1 2 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creating a list this way has a slightly different effect. The list items are left unevaluated. They can be undefined, and Clojure won&amp;rsquo;t complain.&lt;/p&gt;

&lt;p&gt;Using some of Clojures built-in operations, information can be extracted from the data. The following expression returns the first element of the given list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (first &#39;(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot;))
&amp;quot;one&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another operation returns all the elements except the first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (rest &#39;(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot;))
(&amp;quot;two&amp;quot; &amp;quot;three&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;vectors&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;vectors&#34;&gt;Vectors&lt;/h2&gt;

&lt;p&gt;The vector is another data structure, similar to a list. Vectors are zero-based arrays. They can contain any value, and any mix of value types, just like lists. Here are a few examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; [1 2 3]
[1 2 3]
user=&amp;gt; [:a 0 &amp;quot;hello&amp;quot;]
[:a 0 &amp;quot;hello&amp;quot;]
user=&amp;gt; []
[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nice thing about vectors is you don&amp;rsquo;t have to do anything special to use them as data as you do with lists.&lt;/p&gt;

&lt;p&gt;Other languages give you a handy syntax for getting an array&amp;rsquo;s element by its index. So, how is this accomplished with Clojure&amp;rsquo;s vectors? Perform an operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; ([7 8 9] 2)
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we fetch the value at index &lt;code&gt;2&lt;/code&gt;, which is &lt;code&gt;9&lt;/code&gt;. The vector itself is the operator of the form. This may seem a little weird at first, but eventually it makes a lot of sense. Its argument is &lt;code&gt;2&lt;/code&gt;. The general form for this operation is &lt;code&gt;(vector index)&lt;/code&gt;. Compare this with JavaScript, which is similar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[7, 8, 9][2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the same operation on vectors as we did earlier with lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (first [7 8 9])
7
user=&amp;gt; (last [7 8 9])
9
user=&amp;gt; (rest [7 8 9])
(8 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That last one was a bit unexpected. It didn&amp;rsquo;t return a vector. It looks like a list instead.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;maps-sets&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;maps-and-sets&#34;&gt;Maps and Sets&lt;/h2&gt;

&lt;p&gt;In addition to lists as a data type, Clojure provides syntax for defining &lt;em&gt;maps&lt;/em&gt; and &lt;em&gt;sets&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Maps define a set of unique key-value pairs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; {&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3}
{&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The map above maps the string &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; to the number &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt; to the number &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;&amp;quot;c&amp;quot;&lt;/code&gt; to the number &lt;code&gt;3&lt;/code&gt;. The commas between each pair are optional, to enhance readability of the code. Clojure treats the commas nearly the same as whitespace. You can put commas anywhere between elements of an expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; {&amp;quot;a&amp;quot; 1 &amp;quot;b&amp;quot; 2 &amp;quot;c&amp;quot; 3}
{&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3}
user=&amp;gt; {&amp;quot;a&amp;quot;, 1, &amp;quot;b&amp;quot;, 2, &amp;quot;c&amp;quot;, 3}
{&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3}
user=&amp;gt; {&amp;quot;a&amp;quot;  1 ,&amp;quot;b&amp;quot; 2 ,&amp;quot;c&amp;quot; 3}
{&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that Clojure REPL adds commas to the formatted return value.&lt;/p&gt;

&lt;p&gt;Once a map is defined, its values can be looked up from key values using the &lt;code&gt;get&lt;/code&gt; form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (get {&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;a&amp;quot;)
1
user=&amp;gt; (get {&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;b&amp;quot;)
2
user=&amp;gt; (get {&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;c&amp;quot;)
3
user=&amp;gt; (get {&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;d&amp;quot;)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, theres a shortcut for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; ({&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;a&amp;quot;)
1
user=&amp;gt; ({&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;b&amp;quot;)
2
user=&amp;gt; ({&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;c&amp;quot;)
3
user=&amp;gt; ({&amp;quot;a&amp;quot; 1, &amp;quot;b&amp;quot; 2, &amp;quot;c&amp;quot; 3} &amp;quot;d&amp;quot;)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similar to Vectors and lists, Maps can be used as functions of their keys.&lt;/p&gt;

&lt;p&gt;There is yet a third way to get a value from a key:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (:a {:a 1, :b 2, :c 3})
1
user=&amp;gt; (:b {:a 1, :b 2, :c 3})
2
user=&amp;gt; (:c {:a 1, :b 2, :c 3})
3
user=&amp;gt; (:d {:a 1, :b 2, :c 3})
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its important to get familiar with the last two usages, as they are commonly used in Clojure programs.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;defs&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;defining-variables-and-functions&#34;&gt;Defining Variables and Functions&lt;/h2&gt;

&lt;h3 id=&#34;def&#34;&gt;&lt;code&gt;def&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;To bind a symbol to a value, use the &lt;code&gt;def&lt;/code&gt; form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (def x 5)
#&#39;user/x
user=&amp;gt; x
5
user=&amp;gt; (+ 5 x)
10
user=&amp;gt; (def my-list &#39;(1 2 3))
#&#39;user/my-list
user=&amp;gt; my-list
(1 2 3)
user=&amp;gt; (last my-list)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There a a few things going on when a variable is created. What gets returned from &lt;code&gt;def&lt;/code&gt; is a &lt;em&gt;var&lt;/em&gt;, which is a an object that holds a value, such as &lt;em&gt;5&lt;/em&gt;. Also, a symbol is created, and that symbol is bound to the var.&lt;/p&gt;

&lt;h3 id=&#34;defn&#34;&gt;&lt;code&gt;defn&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Functions can be created using &lt;code&gt;defn&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (defn election-year? [year]
  (zero? (rem year 4)))
#&#39;user/election-year?
user=&amp;gt; (election-year? 2007)
false
user=&amp;gt; (election-year? 2008)
true
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functions are just a kind of object that can be called.&lt;/p&gt;

&lt;p&gt;The first argument to a &lt;code&gt;defn&lt;/code&gt; is the functions name, which becomes a symbol bound to the function. The second argument is the functions argument list. Argument lists are always represented by a vector. The remaining arguments of &lt;code&gt;defn&lt;/code&gt; can be one or more expressions. The result of the last expression is used as the functions return value.&lt;/p&gt;

&lt;h3 id=&#34;using-fn&#34;&gt;Using &lt;code&gt;fn&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Anonymous functions can be created using &lt;code&gt;fn&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (fn [x] (+ x 1))
user.eval__2384$fn__2386@c4b579
user=&amp;gt; ((fn [x] (+ x 1)) 9)
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since functions are just objects, they can be bound to a symbol (assigned to a variable):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (def plus-one
     (fn [x] (+ x 1)))
#&#39;user/plus-one
user=&amp;gt; (plus-one 9)
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;defn&lt;/code&gt; form is just a macro that turns its contents into a &lt;code&gt;def&lt;/code&gt; + &lt;code&gt;fn&lt;/code&gt; combination.&lt;/p&gt;

&lt;h3 id=&#34;the-doc-form&#34;&gt;The &lt;code&gt;doc&lt;/code&gt; form&lt;/h3&gt;

&lt;p&gt;Nearly all the forms in Clojure have built-in documentation. To quickly find out about a form, pass the forms name to the &lt;code&gt;doc&lt;/code&gt; form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (doc first)
-------------------------
clojure/first
([coll])
  Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;documenting-a-function&#34;&gt;Documenting a function&lt;/h3&gt;

&lt;p&gt;There are multiple ways to add documentation to a function. Here is the easiest:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (defn plus-one
  &amp;quot;Returns a number one greater than x&amp;quot;
  [x]
  (+ x 1))
#&#39;user/plus-one
user=&amp;gt; (doc plus-one)
-------------------------
user/plus-one
([x])
  Returns a number one greater than x
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is another way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (defn plus-one
  {:doc &amp;quot;Returns a number one greater than x&amp;quot;}
  [x]
  (+ x 1))
#&#39;user/plus-one
user=&amp;gt; (doc plus-one)
-------------------------
user/plus-one
([x])
  Returns a number one greater than x
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;special-forms&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;special-forms&#34;&gt;Special Forms&lt;/h2&gt;

&lt;p&gt;Clojure has several built-in forms, known collectively as &lt;em&gt;special forms&lt;/em&gt;. This section introduces them and delves further into the types of expressions that are possible with Clojure.&lt;/p&gt;

&lt;h3 id=&#34;the-str-form&#34;&gt;The &lt;code&gt;str&lt;/code&gt; form:&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;str&lt;/code&gt; form concatenates two or more values, converting them to strings if necessary, and returns the result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (str &amp;quot;Hello,&amp;quot; &amp;quot; world!&amp;quot;)
&amp;quot;Hello, world!&amp;quot;
user=&amp;gt; (str 5)
&amp;quot;5&amp;quot;
user=&amp;gt; (str &amp;quot;Value: &amp;quot; 5)
&amp;quot;Value: 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-if-form&#34;&gt;The &lt;code&gt;if&lt;/code&gt; form&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;if&lt;/code&gt; form is similar to the &lt;code&gt;if&lt;/code&gt; statement in C-like languages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (if true &amp;quot;yes&amp;quot;)
&amp;quot;yes&amp;quot;
user=&amp;gt; (if false &amp;quot;yes&amp;quot;)
nil
user=&amp;gt; (if false &amp;quot;yes&amp;quot; &amp;quot;no&amp;quot;)
&amp;quot;no&amp;quot;
user=&amp;gt; (if nil &amp;quot;yes&amp;quot; &amp;quot;no&amp;quot;)
&amp;quot;no&amp;quot;
user=&amp;gt; (if &amp;quot;&amp;quot; true)
true
user=&amp;gt; (if 0 true)
true
user=&amp;gt; (if true &amp;quot;yes&amp;quot; &amp;quot;no&amp;quot;)
&amp;quot;yes&amp;quot;
user=&amp;gt; (if (= 1 1) &amp;quot;yes&amp;quot; &amp;quot;no&amp;quot;)
&amp;quot;yes&amp;quot;
user=&amp;gt; (if (= 1 1) (+ 2 3) (+ 5 5))
5
user=&amp;gt; (if (= 1 2) (+ 2 3) (+ 5 5))
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the first argument, converted to a boolean, is true, then the second argument is returned. Otherwise the third argument is returned. The third argument is optional.&lt;/p&gt;

&lt;p&gt;In Clojure, when a value is converted to boolean, it is always &lt;span class=&#34;caps&#34;&gt;TRUE&lt;/span&gt;, unless the value is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. There are many forms that make decisions based on whether a value will be true or false when converted to boolean.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;if&lt;/code&gt; form works a lot like the C-language ternary operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;v = true ? 1 : 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ternary operator is usually used in places where an &lt;code&gt;if&lt;/code&gt; statement is too verbose. However, since Clojures &lt;code&gt;if&lt;/code&gt; form is already succinct, there is no need for a separate operator. You can still break up the expression onto separate lines when it makes sense to do so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (if (= 1 1)
  (+ 2 3)
  (+ 3 4))
5
user=&amp;gt; (if (= &amp;quot;foobar&amp;quot; (str &amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;))
  &amp;quot;&#39;foo&#39; plus &#39;bar&#39; equals &#39;foobar&#39;&amp;quot;
  &amp;quot;&#39;foo&#39; plus &#39;bar&#39; does not equal &#39;foobar&#39;&amp;quot;)
&amp;quot;&#39;foo&#39; plus &#39;bar&#39; equals &#39;foobar&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-do-form&#34;&gt;The &lt;code&gt;do&lt;/code&gt; form:&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; form is used to execute a number of operations in sequence. Typically in functional programming, expressions are contained by, or are containers for, other expressions, so there isnt a need to execute operations one after the other. This is fine when the expressions produce a value that will be used by a containing expression. However, there are some occasions where the value of an expression isnt used. If such an expression does anything useful at all, it is said to have side effects. For example, writing something to standard output, or a file, or a database, are all examples of side-effects.&lt;/p&gt;

&lt;p&gt;Clojure provides the &lt;code&gt;println&lt;/code&gt; form for writing to standard output. In order to use &lt;code&gt;println&lt;/code&gt; within an expression whose return value we care about, we need to put it in a &lt;code&gt;do&lt;/code&gt; expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (do (println &amp;quot;Hello.&amp;quot;) (+ 2 2))
Hello.
4
user=&amp;gt; (do (println &amp;quot;Hello.&amp;quot;) (println &amp;quot;Hello again.&amp;quot;) (+ 2 2))
Hello.
Hello again.
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; operation executes each expression in sequence and returns the result of the last expression.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; form isnt the only form that lets you perform a number of operations in sequence. &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;defn&lt;/code&gt; and &lt;code&gt;fn&lt;/code&gt; all let you do that too.&lt;/p&gt;

&lt;p&gt;One of the things that takes some getting used to is that Clojure is a functional language. All expressions in Clojure return a value. Often, a single Clojure expression will span several lines, where the C-like programmer would write it out the same logic as a block of code consisting of several distinct statements. The distinct statements may assign a value to a variable to be used in the following statements. Programs written in functional languages tend to have larger statements spanning multiple lines rather than a multiline block of code split into smaller statements. This way of building programs can take some getting used to, but once youve learned it, the new way can be just as easy as the old. There are several advantages to writing programs this way.&lt;/p&gt;

&lt;h3 id=&#34;the-when-form&#34;&gt;The &lt;code&gt;when&lt;/code&gt; form&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;when&lt;/code&gt; form is similar to the &lt;code&gt;if&lt;/code&gt; form. The differences are that there is no else condition, and more than one expression can be added to the &lt;code&gt;when&lt;/code&gt; form for evaluation when the condition is &lt;span class=&#34;caps&#34;&gt;TRUE&lt;/span&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (when nil &amp;quot;Should return &#39;nil&#39;&amp;quot;)
nil
user=&amp;gt; (when false &amp;quot;Should return &#39;nil&#39;&amp;quot;)
nil
user=&amp;gt; (when true &amp;quot;Yes&amp;quot;)
&amp;quot;Yes&amp;quot;
user=&amp;gt; (when true 1)
1
user=&amp;gt; (when true 1 2 3)
3
user=&amp;gt; (when true
  (println &amp;quot;Hello, world&amp;quot;)
  &amp;quot;Yes&amp;quot;)
Hello, world
&amp;quot;Yes&amp;quot;
user=&amp;gt; (when (= 5 (inc 4))
  &amp;quot;Yes&amp;quot;)
&amp;quot;Yes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-let-form&#34;&gt;The &lt;code&gt;let&lt;/code&gt; form&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;let&lt;/code&gt; operator is used for setting up and holding temporary values to be used by a containing operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (let [x 2] (+ x 8))
10
user=&amp;gt; (let [x 2 y 8] (+ x y))
10
user=&amp;gt; (let [x 2 y 8] (= (+ x y) 10))
true
user=&amp;gt; (let [x 3] (+ (* x x) 1))
10
user=&amp;gt; (let [color &amp;quot;Red&amp;quot;] (str &amp;quot;Color is: &amp;quot; color))
&amp;quot;Color is: Red&amp;quot;
user=&amp;gt; (let [color &amp;quot;Red&amp;quot; phrase (str &amp;quot;Color is: &amp;quot; color)]
  (str &amp;quot;Clojure says: &amp;quot; phrase))
&amp;quot;Clojure says: Color is: Red&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;let&lt;/code&gt; form creates a temporary var (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in this case), that can only be used inside the body of the &lt;code&gt;let&lt;/code&gt; expression. A vector is used to define the var and its value, and vectors are also used by other Clojure forms to declare a list of temporary variables and their assigned values. The vector contains name-value pairs.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;looping-iterating&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;looping-and-iterating&#34;&gt;Looping and Iterating&lt;/h2&gt;

&lt;p&gt;Here are three ways to loop while incrementing an index from 0 to 4 (5 iterations):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (loop [i 0]
  (when (&amp;lt; i 5)
    (println i)
    (recur (inc i))))
0
1
2
3
4
nil
user=&amp;gt; (dorun (for [i (range 0 5)]
         (println i)))
0
1
2
3
4
nil
user=&amp;gt; (doseq [i (range 0 5)]
  (println i))
0
1
2
3
4
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first example uses the &lt;code&gt;loop&lt;/code&gt; form, which provides the most flexibility, but requires the most syntactical overhead. The second and third examples are examples of iterating over a sequence, which is a more common kind of looping. The &lt;code&gt;dorun&lt;/code&gt; and &lt;code&gt;doseq&lt;/code&gt; calls suppress the return values of the containing expressions.&lt;/p&gt;

&lt;p&gt;Lets look at the &lt;code&gt;loop&lt;/code&gt; form a little closer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (loop [i 0]
  (when (&amp;lt; i 5)
    (println &amp;quot;i:&amp;quot; i)
    (recur (inc i))))
i: 0
i: 1
i: 2
i: 3
i: 4
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, the temporary symbol &lt;code&gt;i&lt;/code&gt; is bound to a value of &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;when&lt;/code&gt; statement checks to see if &lt;code&gt;i&lt;/code&gt; is less than &lt;code&gt;5&lt;/code&gt;. If the test passes, the two expressions inside are evaluated. The &lt;code&gt;println&lt;/code&gt; expression outputs the value of &lt;code&gt;i&lt;/code&gt;. Next, the &lt;code&gt;recur&lt;/code&gt; form is evaluated, which instructs the loop to iterate again with a new value for &lt;code&gt;i&lt;/code&gt;. The &lt;code&gt;(inc i)&lt;/code&gt; is short for &lt;code&gt;(+ i 1)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Without the &lt;code&gt;recur&lt;/code&gt;, a &lt;code&gt;loop&lt;/code&gt; expression behaves exactly the same as a &lt;code&gt;let&lt;/code&gt; expression.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;sequences&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sequences&#34;&gt;Sequences&lt;/h2&gt;

&lt;p&gt;Sequences are in a sense, the core of idiomatic Clojure programming. Understand sequences and the forms that work with them, and you will have cleared one of the biggest hurdles to writing significant Clojure programs.&lt;/p&gt;

&lt;p&gt;At first glance, a Sequence looks like another data structure. However, a Sequence is not a data structure. It is an interface, or view, into a data structure. A sequence can be derived from a collection. The relation between collection and sequence is similar to the relation between database table and database view.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://clojure.org/sequences&#34;&gt;Clojures section on Sequences&lt;/a&gt; gives an excellent definition.&lt;/p&gt;

&lt;p&gt;Lets get a sequence from a vector:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (seq [1 2 3])
(1 2 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This bit of code doesnt merely convert the vector into a list. It calls on the vector to produce a sequence of the vector. The &lt;span class=&#34;caps&#34;&gt;REPL&lt;/span&gt; (Read, Evaluate, Print, Loop), as part of its Print step, uses the sequence to produce a list so that something meaningful can be displayed.&lt;/p&gt;

&lt;p&gt;One way to keep the &lt;span class=&#34;caps&#34;&gt;REPL&lt;/span&gt; from creating a list from the sequence is to enclose the expression in another expression that doesnt consume the sequence. For example, a method call of the sequence will not consume the sequence. Take &lt;code&gt;getClass()&lt;/code&gt; for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (.getClass (seq [1 2 3]))
clojure.lang.APersistentVector$Seq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What gets returned is an APersistentVector$Seq, which is the class that represents a vectors sequence.&lt;/p&gt;

&lt;p&gt;All of Clojures built-in data structures have methods to produce a sequence. The sequence interface is formally named clojure.lang.iSeq, or iSeq.&lt;/p&gt;

&lt;h3 id=&#34;first&#34;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Use &lt;code&gt;first&lt;/code&gt; to get the first item in a sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (first (seq [1 2 3]))
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;first&lt;/code&gt; will also take a vector directly, implicitly converting it into a sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (first [1 2 3])
1
user=&amp;gt; (first [&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;])
&amp;quot;a&amp;quot;
user=&amp;gt; (first &#39;(&amp;quot;A&amp;quot; &amp;quot;B&amp;quot; &amp;quot;C&amp;quot;))
&amp;quot;A&amp;quot;
user=&amp;gt; (first &#39;(:a :b :c))
:a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the sequence forms do this implicit conversion, so you can pass any collection that provides an iSeq interface, including any of Clojures built-in collection types.&lt;/p&gt;

&lt;h3 id=&#34;rest&#34;&gt;&lt;code&gt;rest&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rest&lt;/code&gt; produces a sequence that consists of every item of the original sequence, minus the first item.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (rest [1 2 3])
(2 3)
user=&amp;gt; (rest [&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;])
(&amp;quot;b&amp;quot; &amp;quot;c&amp;quot;)
user=&amp;gt; (rest &#39;(&amp;quot;A&amp;quot; &amp;quot;B&amp;quot; &amp;quot;C&amp;quot;))
(&amp;quot;B&amp;quot; &amp;quot;C&amp;quot;)
user=&amp;gt; (rest [:a :b :c])
(:b :c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that no new data structure is created. &lt;code&gt;rest&lt;/code&gt; only creates a logical list (a sequence). It is up to the caller to create a data structure, if needed. In the examples above, the caller is the &lt;span class=&#34;caps&#34;&gt;REPL&lt;/span&gt;, and it collects the sequence into a list so that it can display something meaningful. It is computationally inexpensive to create a sequence.&lt;/p&gt;

&lt;h3 id=&#34;cons&#34;&gt;&lt;code&gt;cons&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cons&lt;/code&gt; creates a new sequence by prepending an element onto a collection. The element is the first argument, and the collection is the second.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (cons 1 [2 3])
(1 2 3)
user=&amp;gt; (cons :a [:b :c])
(:a :b :c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, no data structure is created by &lt;code&gt;cons&lt;/code&gt;. The resulting sequence internally consists of separate pointers to the first and second arguments of &lt;code&gt;cons&lt;/code&gt;. To the user or consumer of the sequence, it appears as one continuous sequence.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;java-integration&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;java-integration&#34;&gt;Java Integration&lt;/h2&gt;

&lt;p&gt;Clojure provides the ability to interface with Java objects and primitives. Knowing how to do this is essential for non-trival programs.&lt;/p&gt;

&lt;p&gt;Lets start by instantiating a Java &lt;code&gt;java.util.Date&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (new java.util.Date)
Mon May 26 10:25:25 PDT 2008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojure instantiates the &lt;code&gt;Date&lt;/code&gt; object, then calls and displays its &lt;code&gt;toString()&lt;/code&gt; method as a visual representation of the object.&lt;/p&gt;

&lt;p&gt;To pass arguments to the objects constructor, just include them in the call to &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (new StringBuffer &amp;quot;This is the initial value&amp;quot;)
This is the initial value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a shortcut syntax for instantiation. Replace the &lt;code&gt;new&lt;/code&gt; operator and the Java class with only the Java class, but with a period appended to its name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (StringBuffer. &amp;quot;This is the initial value&amp;quot;)
This is the initial value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To call a method on an instance, use the special dot-method (&lt;code&gt;.&amp;lt;method&amp;gt;&lt;/code&gt;) form. The operator in this form consists of the method name, prepended with a period. The second argument is the object whose method is called:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(.toString (new java.util.Date))
&amp;quot;Thu Apr 05 21:44:36 PDT 2012&amp;quot;
(.toString (java.util.Date.))
&amp;quot;Thu Apr 05 21:45:22 PDT 2012&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the operator and object, any additional arguments are passed as arguments to the method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (def my-hash (java.util.HashMap.))
#&#39;user/my-hash
user=&amp;gt; (.put my-hash &amp;quot;food&amp;quot; &amp;quot;tacos&amp;quot;)
nil
user=&amp;gt; (.get my-hash &amp;quot;food&amp;quot;)
&amp;quot;tacos&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, a &lt;code&gt;symbol&lt;/code&gt; called &lt;code&gt;my-hash&lt;/code&gt; is created and bound to a HashMap instance. Then a value is added to the HashMap for the key &lt;code&gt;&amp;quot;food&amp;quot;&lt;/code&gt;. Then the value is retrieved from the HashMap.&lt;/p&gt;

&lt;p&gt;Static (class) fields and methods are called with a different syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (Integer/MAX_VALUE)
2147483647
user=&amp;gt; (Character/TYPE)
char
user=&amp;gt; (Boolean/valueOf &amp;quot;true&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like with Java, Clojure provides the means to import classes into the current context, so that classes do not need to be written out using the fully-qualified syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (import &#39;(java.io FileReader))
nil
user=&amp;gt; (FileReader. &amp;quot;source.txt&amp;quot;)
java.io.FileReader@f784d7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple classes within a package can be included, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (import &#39;(java.io File FileReader))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both the &lt;code&gt;File&lt;/code&gt; and &lt;code&gt;FileReader&lt;/code&gt; classes are&lt;/p&gt;

&lt;p&gt;imported above.&lt;/p&gt;

&lt;p&gt;If the classes are in different packages, use this syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (import &#39;(java.io File) &#39;(java.util HashMap))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can use two separate import statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (import &#39;(java.io File))
nil
user=&amp;gt; (import &#39;(java.util HashMap))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;libraries&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-clojure-libraries&#34;&gt;Using Clojure Libraries&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re writing an application, you&amp;rsquo;ll probably end up using a third party library.&lt;/p&gt;

&lt;h3 id=&#34;leiningen&#34;&gt;Leiningen&lt;/h3&gt;

&lt;p&gt;The ideal way to import libraries is to use a packaging tool called Leiningen.&lt;/p&gt;

&lt;p&gt;First, &lt;a href=&#34;https://github.com/technomancy/leiningen/&#34;&gt;install Leiningen&lt;/a&gt;. In order to do its job, Leiningen needs to create a new project directory for your project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; lein new my-project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the new project directory, it puts a file, &lt;code&gt;project.clj&lt;/code&gt; that represents your project to Leiningen. Go ahead an edit this file, changing the project description to match your tastes.&lt;/p&gt;

&lt;p&gt;There are two main repositories for Clojure libraries: &lt;a href=&#34;http://dev.clojure.org/display/doc/Clojure+Contrib&#34;&gt;Clojure Contrib&lt;/a&gt;, and &lt;a href=&#34;https://clojars.org/&#34;&gt;Clojars&lt;/a&gt;. We&amp;rsquo;ll look at Clojure Contrib.&lt;/p&gt;

&lt;h3 id=&#34;clojure-contrib&#34;&gt;Clojure Contrib&lt;/h3&gt;

&lt;p&gt;The libraries in Clojure Contrib can be found at &lt;a href=&#34;http://dev.clojure.org/display/doc/Clojure+Contrib&#34;&gt;the Clojure Contrib libraries list&lt;/a&gt;. Choose a library to use. For this tutorial, we&amp;rsquo;ll use &lt;code&gt;data.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Edit your &lt;code&gt;project.clj&lt;/code&gt; file. Add a new vector to the &lt;code&gt;:dependencies&lt;/code&gt; vector. This new vector will contain two elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;[org.clojure/data.json &amp;quot;0.1.2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Clojure Contrib libraries and any other libraries associated with the Clojure project, the dependency path with start with &lt;code&gt;org.clojure/&lt;/code&gt;, followed by the library name, &lt;code&gt;data.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So now, the &lt;code&gt;:dependencies&lt;/code&gt; vector will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;:dependencies [[org.clojure/clojure &amp;quot;1.4.0&amp;quot;]
               [org.clojure/data.json &amp;quot;0.1.2&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using Leiningen for your project, you need to use lein to get to the REPL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; lein repl
REPL started; server listening on localhost port 64984
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the library can be referenced from your code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (use &#39;[clojure.data.json :only (read-json json-str)])
nil
user=&amp;gt; (json-str {:color &amp;quot;red&amp;quot; :name &amp;quot;apple&amp;quot;})
&amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;apple\&amp;quot;,\&amp;quot;color\&amp;quot;:\&amp;quot;red\&amp;quot;}&amp;quot;
user=&amp;gt; (read-json &amp;quot;{\&amp;quot;width\&amp;quot;: 300, \&amp;quot;height\&amp;quot;: 200}&amp;quot;)
{:width 300, :height 200}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;resources&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;additional-resources&#34;&gt;Additional Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://clojuredocs.org/&#34;&gt;ClojureDocs: http://clojuredocs.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikibooks.org/wiki/Clojure_Programming&#34;&gt;Clojure Programming Wikibook: http://en.wikibooks.org/wiki/Clojure_Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
		</item>
		
		<item>
			<title>Ruby: Escape, Unescape, Encode, Decode, HTML, XML, URI, URL</title>
			<link>http://www.moxleystratton.com/ruby-escape-unescape-encode-decode-html-xml-uri-url/</link>
			<pubDate>Tue, 31 Jul 2007 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/ruby-escape-unescape-encode-decode-html-xml-uri-url/</guid>
			<description>&lt;p&gt;This example shows you how to escape and un-escape a value to be included in a URI and within HTML.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;cgi&#39;

# Escape data for URL query parameters
name = &amp;quot;ruby?&amp;quot;
value = &amp;quot;yes&amp;quot;
url = &amp;quot;http://example.com/?&amp;quot; + CGI.escape(name) + &#39;=&#39; + CGI.escape(value) + &amp;quot;&amp;amp;var=T&amp;quot;
# url: http://example.com/?ruby%3F=yes&amp;amp;var=T

# Escape data for HTML
url = &amp;quot;http://example.com/?ruby%3F=yes&amp;amp;var=T&amp;quot;
html = %(&amp;lt;a href=&amp;quot;#{CGI.escapeHTML(url)}&amp;quot;&amp;gt;example&amp;lt;/a&amp;gt;)
# html: &amp;lt;a href=&amp;quot;http://example.com/?ruby%3F=yes&amp;amp;amp;var=T&amp;quot;&amp;gt;example&amp;lt;/a&amp;gt;

# Unescape HTML-escaped data
url = CGI.unescapeHTML(&amp;quot;http://example.com/?ruby%3F=yes&amp;amp;amp;var=T&amp;quot;)
# url: http://example.com/?ruby%3F=yes&amp;amp;var=T

# Parse query params:
query = &amp;quot;ruby%3F=yes&amp;amp;var=T&amp;quot;
pairs = query.split(&#39;&amp;amp;&#39;)    # pairs: [&amp;quot;ruby%3F=yes&amp;quot;, &amp;quot;var=T&amp;quot;]
name, value = pairs[0].split(&#39;=&#39;).map{|v| CGI.unescape(v)}
# name, value: [&amp;quot;ruby?&amp;quot;, &amp;quot;yes&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
</description>
		</item>
		
		<item>
			<title>Bookmarklet Compiler</title>
			<link>http://www.moxleystratton.com/bookmarklet-compiler/</link>
			<pubDate>Wed, 11 Jan 2006 12:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/bookmarklet-compiler/</guid>
			<description>

&lt;p&gt;What are bookmarklets? They&amp;rsquo;re small Javascripts, saved as browser bookmarks, that perform useful functions. Here&amp;rsquo;s my favorite &lt;a href=&#34;http://www.squarefree.com/bookmarklets/&#34;&gt;bookmarklet site&lt;/a&gt;. It includes the bookmarklet that helped me develop my first Ajax applications: &lt;a href=&#34;http://www.squarefree.com/shell/&#34;&gt;Javascript Shell&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;how-do-you-make-a-bookmarklet&#34;&gt;How do you make a bookmarklet?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Write the javascript that you want to be the bookmarklet.&lt;/li&gt;
&lt;li&gt;Escape all the special URL characters, like space, parentheses, etc.&lt;/li&gt;
&lt;li&gt;Wrap the script in an anonymous Javascript function&lt;/li&gt;
&lt;li&gt;Wrap the function in a Javascript URL (&lt;code&gt;javascript:...&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Better yet, just do step #1 and use the bookmarklet maker below to do the rest.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;bookmarklet-maker&#34;&gt;Bookmarklet Maker&lt;/h2&gt;

&lt;p&gt;This form will take your nicely-formatted Javascript, and turn it into a URL so that you can bookmark it.&lt;/p&gt;

&lt;p&gt;Go ahead and enter some javascript.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;http://www.moxleystratton.com/bookmarklet/bookmarklet-compiler.js&#34;&gt;&lt;/script&gt;

&lt;form id=&#34;bookmarkletGenerator&#34; method=&#34;get&#34; action=&#34;javascript:;&#34;&gt;
  &lt;textarea cols=&#34;80&#34; rows=&#34;10&#34; id=&#34;source&#34;&gt;&lt;/textarea&gt;

  &lt;input type=&#34;button&#34; onclick=&#34;Bookmarklet.forPost()&#34; value=&#34;Make Bookmarket&#34;/&gt;
&lt;/form&gt;

&lt;div id=&#34;generated&#34;&gt;&lt;/div&gt;

&lt;style type=&#34;text/css&#34;&gt;#generated { margin-top: 10px; padding: 0 10px; background-color: #aef; }&lt;/style&gt;

&lt;p&gt;The Javascript function for creating the bookmarklet maker can be downloaded &lt;a href=&#34;https://raw.github.com/moxley/misc/master/bookmarklet-compiler.js&#34;&gt;from Github&lt;/a&gt;&lt;/p&gt;
</description>
		</item>
		
		<item>
			<title>Search articles</title>
			<link>http://www.moxleystratton.com/search/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
			<author></author>
			<guid>http://www.moxleystratton.com/search/</guid>
			<description>&lt;p&gt;Search for something:&lt;/p&gt;
</description>
		</item>
		
	</channel>
</rss>
