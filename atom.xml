<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Moxley Stratton]]></title>
  <link href="http://moxley.github.io/atom.xml" rel="self"/>
  <link href="http://moxley.github.io/"/>
  <updated>2014-11-24T19:50:48-08:00</updated>
  <id>http://moxley.github.io/</id>
  <author>
    <name><![CDATA[Moxley Stratton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sometimes Clojure Is More Concise Than Ruby]]></title>
    <link href="http://moxley.github.io/blog/2014/11/24/sometimes-clojure-is-more-concise-than-ruby/"/>
    <updated>2014-11-24T19:00:00-08:00</updated>
    <id>http://moxley.github.io/blog/2014/11/24/sometimes-clojure-is-more-concise-than-ruby</id>
    <content type="html"><![CDATA[<p>I find that 90% of the time, Clojure is more verbose than Ruby. Here&rsquo;s one simple example where Clojure wins a conciseness battle:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; Subtract two vectors in Clojure</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">9</span> <span class="mi">8</span><span class="p">])</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
</span><span class='line'><span class="p">(</span><span class="nb">map - </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; (9 7 5)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Subtract two vectors in Ruby</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="o">]</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">|</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># [9, 7, 5]</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is it about Ruby that makes it less concise in this example?</p>

<p>In my opinion, the OOP nature of Ruby gets in the way. In OOP, there is a message receiver
(the object), plus zero or more arguments. In Clojure, there is no receiver, only arguments.
In Ruby, the two arguments to Clojure&rsquo;s <code>map</code> call have to be split up into the receiver
and the first argument. Additionally, the arguments to Ruby&rsquo;s <code>map</code> arrive as a single
array instead of of two distinct scalar arguments. This requires the destructor
parentheses inside the <code>map</code> block.</p>

<p>The syntactical division between a receiver and it&rsquo;s arguments is usually not a problem.
But every once in a while, it gets in the way. Another division in OOP is between class
and instance. I&rsquo;ve found that this division can sometimes get in the way too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding the Source for a Given Rails Web Page]]></title>
    <link href="http://moxley.github.io/blog/2014/05/29/finding-the-source-for-a-given-rails-web-page/"/>
    <updated>2014-05-29T12:00:00-07:00</updated>
    <id>http://moxley.github.io/blog/2014/05/29/finding-the-source-for-a-given-rails-web-page</id>
    <content type="html"><![CDATA[<p>These tips may help those of you who are relatively new to Rails, or maybe even if you&rsquo;re not.</p>

<h2>Common tips and tricks</h2>

<ul>
<li>Look at the URL path (e.g. <code>/users/100685/edit</code>).
Can the action and main view file be determined from CRUD/REST conventions?

<ul>
<li><code>/:model/edit</code> -> edit.html.slim</li>
<li><code>/:model/1234</code> -> show.html.slim</li>
<li><code>/:model/new</code> -> new.html.slim</li>
<li><code>/:model</code> -> index.html.slim</li>
</ul>
</li>
<li>Look up the path in routes.rb, or even more useful, run <code>rake routes</code></li>
</ul>


<h2>Finding a controller and action responsible for a given page</h2>

<ol>
<li>In development go to your server&rsquo;s output, and clear the screen (<code>Ctrl+L</code>,
for Linux, <code>Cmd-K</code> for OS X)</li>
<li>Refresh the web page</li>
<li>Back to the server&rsquo;s output, scroll to the top of the output. About the second
line of non-blank log output, you should see something like:
<code>Processing by UserseController#edit as HTML</code>. That&rsquo;s the
controller (<code>UsersController</code>) and action (<code>edit</code>).</li>
</ol>


<h2>Finding a view file for a given page</h2>

<ul>
<li>If in development, look at the server log. If it is too noisy, use
<code>tail -f log/development | grep Rendered</code> to cut out the noise.</li>
<li>If in development, add the <code>rails_view_annotator</code> gem to your Gemfile,
and look at the DOM or HTML source. It should have HTML comments identifying
the view partials responsible for their generated HTML.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Considering a Switch to the Atom Text Editor?]]></title>
    <link href="http://moxley.github.io/blog/2014/03/16/considering-a-switch-to-the-atom-text-editor/"/>
    <updated>2014-03-16T12:00:00-07:00</updated>
    <id>http://moxley.github.io/blog/2014/03/16/considering-a-switch-to-the-atom-text-editor</id>
    <content type="html"><![CDATA[<p>You&rsquo;ve probably heard of <a href="http://atom.io/">Atom, Github&rsquo;s new text editor</a>. Read
these checklists to help you decide whether it&rsquo;s an editor worth switching to.</p>

<h2>General Pros</h2>

<ul>
<li>Open Source</li>
<li>High-quality extension and enhancement infrastructure</li>
<li>View is programmable using good old HTML DOM and CSS</li>
<li>Well-known API model (NodeJS)</li>
<li>Built-in Github integration</li>
<li>Built-in, light Git integration</li>
<li><a href="https://www.youtube.com/watch?v=VGUemwCaBR0&amp;amp;feature=youtu.be">Realtime Markdown preview</a></li>
<li>Seamlessly tracks external file renames while the file is open</li>
<li>Browse archive files, like zip or tar.gz, like Emacs does.</li>
<li>UI and editing features basically a clone of Sublime Text</li>
<li>Free, while in Beta.</li>
</ul>


<h2>General Cons</h2>

<ul>
<li>In Beta. Some rough UX details.</li>
<li>No keyboard macros</li>
<li>No command documentation</li>
<li>Difficult to discover available commands</li>
<li>Currently only works on OS X (Windows and Linux planned)</li>
</ul>


<h2>For Sublime Users</h2>

<h3>Pros</h3>

<ul>
<li>Package manager is built in</li>
<li>Deep customization API</li>
<li>Fine-grained commands</li>
<li>Complete pane splitting and pane navigation</li>
<li>Smarter indentation of pasted text</li>
</ul>


<h3>Cons</h3>

<ul>
<li>2-3x slower, 2-3x more memory than ST3 (realistically, it&rsquo;s not as bad as it sounds)</li>
<li>No &ldquo;Jump Back&rdquo; feature, as found in ST3</li>
<li>No auto-highlighting matching strings of selected string</li>
<li>Can&rsquo;t open file in existing window, unless it lives within the window&rsquo;s directory</li>
<li>Missing key bindings for many search &amp; replace operations</li>
</ul>


<h2>For Vim and Emacs Users</h2>

<h3>Pros</h3>

<ul>
<li>Modern Application and UI, contemporary key bindings</li>
<li>Easy to learn</li>
<li>Built in Package manager, and standard package formats</li>
<li>View is good old HTML DOM, CSS</li>
<li>CoffeeScript is arguably better than eLisp and Vimscript</li>
<li>Editor API reaches deep into the editor</li>
<li>Project-wide fuzzy file finder, built in, fuss-free</li>
<li>Buffer-wide fuzzy symbol finder, built in, fuss-free</li>
<li>Project-wide string search</li>
<li>Large number of homerow-close key bindings (many of them are Emacs compatible)</li>
<li>Pane splitting on par with Vim and Emacs</li>
<li>Multi selections</li>
<li>Code Snippets</li>
</ul>


<h3>Cons</h3>

<ul>
<li>Costs money</li>
<li>Core is closed-source for now</li>
<li>Editor API doesn&rsquo;t go as deep as Emacs. Lacks rich callback API that Emacs has.</li>
<li>No cursor history, so no command for going back to the last location without using bookmarks</li>
<li>No cursor navigation around, or editing operations on, symbol definitions (e.g., methods)</li>
<li>Unlike Emacs, no built-in shell console (package under development)</li>
<li>Keyboard navigation of file tree is cumbersome, but will likely improve over time.</li>
<li>Missing a lot of the cool text navigation and editing commands available to Vim and Emacs</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Cellular Automata]]></title>
    <link href="http://moxley.github.io/blog/2012/12/01/simple-cellular-automata/"/>
    <updated>2012-12-01T12:00:00-08:00</updated>
    <id>http://moxley.github.io/blog/2012/12/01/simple-cellular-automata</id>
    <content type="html"><![CDATA[<p>I released a very simple cellular automata explorer. <a href="http://moxley.github.io/cellauto/cellauto.html">Try it out here</a>.
See the <a href="https://github.com/moxley/cellauto">Github page</a> for more information.</p>
]]></content>
  </entry>
  
</feed>
