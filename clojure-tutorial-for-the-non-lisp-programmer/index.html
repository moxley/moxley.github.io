<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Clojure Tutorial for the Non-Lisp Programmer</title>
		<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.moxleystratton.com/index.xml">
		<link rel="canonical" href="http://www.moxleystratton.com/clojure-tutorial-for-the-non-lisp-programmer/">
		
		<link rel="shortcut icon" type="image/png" href="http://www.moxleystratton.com/apple-touch-icon-precomposed.png">
		
		
		<meta name="generator" content="Hugo 0.49" />

		
		<meta name="og:title" content="Clojure Tutorial for the Non-Lisp Programmer" />
		<meta name="og:type" content="article" />
		<meta name="og:image" content="http://www.moxleystratton.com/img/default-header-img.jpg" />
		<meta name="og:description" content="" />
		<meta name="og:url" content="http://www.moxleystratton.com/clojure-tutorial-for-the-non-lisp-programmer/" />
		<meta name="og:site_name" content="Clojure Tutorial for the Non-Lisp Programmer" />
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:site" content="@" />


		
		<link rel="stylesheet" href="http://www.moxleystratton.com/css/tachyons.min.css" />
		<link rel="stylesheet" href="http://www.moxleystratton.com/css/story.css" />
		<link rel="stylesheet" href="http://www.moxleystratton.com/css/descartes.css" />
		
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
		<link href="https://fonts.googleapis.com/css?family=Quattrocento+Sans:400,400i,700,700i|Quattrocento:400,700|Spectral:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
		

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		
		<script src="http://www.moxleystratton.com/js/story.js"></script>

	</head>
	<body class="ma0 bg-white  page-kind-page is-page-true ">
		
		<header class="cover bg-top" style="background-image: url('http://www.moxleystratton.com/img/default-header-img.jpg'); background-position: center;">
			<div class="bg-black-30 bb bt">

				<nav class="hide-print sans-serif  border-box pa3 ph5-l">
					<a href="http://www.moxleystratton.com/" title="Home">
						<img src="http://www.moxleystratton.com/img/logo.jpg" class="w2 h2 br-100" alt="Moxley Stratton" />
					</a>
					<div class="fr h2 pv2 tr">
						<a class="link f5 ml2 dim near-white fas fa-rss-square" href="http://www.moxleystratton.com/index.xml" title="RSS Feed"></a>
						<a class="link f5 ml2 dim near-white fas fa-search" href="http://www.moxleystratton.com/search/" role="search" title="Search"></a>
					</div>
				</nav>

				<div id="hdr" class="tc-l pv4-ns pv5-l pv2 ph3 ph4-ns">
					<h1 class="near-white mt1-ns f2 fw3 mb0 mt0 lh-title">Clojure Tutorial for the Non-Lisp Programmer</h1>
					<h2 class="near-white mt3-l mb4-l fw1 f6 f3-l measure-wide-l center lh-copy mt2 mb3">
						
						
							
								Published
								<time datetime="2008-05-01T12:00:00Z">May 1, 2008</time>
								<span class="display-print">by </span>
								 in <a href="http://www.moxleystratton.com/categories//clojure" class="no-underline category near-white dim">Clojure</a>
								<span class="display-print">at http://www.moxleystratton.com/clojure-tutorial-for-the-non-lisp-programmer/</span>
							
						
					</h2>
				</div>

				
				
				
				

			</div>
		</header>
		
		<main role="main">
		
<article class="center bg-white br-3 pv1 ph4 nested-copy-line-height lh-copy f4 nested-links mw-100 measure-wide">
	

<p>I intend to keep this tutorial as accurate and up-to-date as possible. If you have any suggestions for changes, please leave a comment at the bottom of this page.</p>

<p>Clojure is a functional lisp dialect that uses the Java Virtual Runtime as its platform. The language home page is at <a href="http://clojure.org/">http://clojure.org/</a>.</p>

<!-- more -->

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
<li><a href="#quick-comparison">A Quick Comparison</a></li>
<li><a href="#install">Installing Clojure</a></li>
<li><a href="#atoms">Atoms</a></li>
<li><a href="#vectors">Vectors</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#maps-sets">Maps and Sets</a></li>
<li><a href="#defs">Defining Variables and Functions</a></li>
<li><a href="#special-forms">Special Forms</a></li>
<li><a href="#looping-iterating">Looping and Iterating</a></li>
<li><a href="#sequences">Sequences</a></li>
<li><a href="#java-integration">Java Integration</a></li>
<li><a href="#libraries">Using Libraries</a></li>
<li><a href="#resources">Additional Resources</a></li>
</ul>

<p><a name="quick-comparison"></a></p>

<h2 id="a-quick-comparison">A Quick Comparison</h2>

<p>In C-like languages, a function call might look something like this:</p>

<pre><code class="language-c">do_something_with(value1, value2)
</code></pre>

<p>In Clojure, the same function call would look like this:</p>

<pre><code class="language-clojure">(do-something-with value1 value2)
</code></pre>

<p>Here, Clojure&rsquo;s syntax differs in these ways:</p>

<ol>
<li>The opening parenthesis is to the left of the function name.</li>
<li>There are no commas delimiting the function parameters.</li>
<li>By convention, words in a function name are separated by dashes.</li>
</ol>

<p>There&rsquo;s not a huge difference.</p>

<p>Here&rsquo;s how adding two values might look in a C-like language:</p>

<pre><code class="language-c">value1 + value2
</code></pre>

<p>And here’s how it would look in Clojure:</p>

<pre><code class="language-clojure">(+ value1 value2)
</code></pre>

<p>In C, the plus operator goes in between the two operands. In Clojure, the operator is always first, and there can be any number of operands. In this way, there is no syntactic difference between operators and function calls. They are the same. This is a thematic difference between Clojure and non-Lisp languages: Clojure is more simple.</p>

<p><a name="install"></a></p>

<h2 id="installing-clojure">Installing Clojure</h2>

<p>A fast and easy way to get started with Clojure is to download and run <a href="https://github.com/arthuredelstein/clooj#readme">Clooj</a>. Clooj is an Integrated Development Environment for Clojure.</p>

<p>As an alternative, the Clojure website provides <a href="http://clojure.org/getting_started">instructions for installing Clojure the traditional way</a>.</p>

<p>The primary way of interacting with Clojure is through the REPL (Read-Evaluate-Print-Loop). The REPL Reads expressions that you give it, Evaluates the expressions, Prints the value that is the result, and Loops around for more input.</p>

<p><a name="atoms"></a></p>

<h1 id="atoms">Atoms</h1>

<p>There are two categories of Clojure expressions, <em>atoms</em> and <em>lists</em>. Atoms are like the primitive types in other languages. Let’s use the <span class="caps">REPL</span> to explore some atoms.</p>

<h3 id="numbers">Numbers</h3>

<pre><code class="language-clojure">user=&gt; 5
5
</code></pre>

<p>The number 5 is evaluated and the result is displayed.</p>

<h3 id="booleans">Booleans</h3>

<p>Here’s another atom:</p>

<pre><code class="language-clojure">user=&gt; true
true
</code></pre>

<p>Clojure supports boolean <code>TRUE</code> and <code>FALSE</code> values, represented as <code>true</code> and <code>false</code> respectively.</p>

<h3 id="nil">Nil</h3>

<p>Here is another important atom:</p>

<pre><code class="language-clojure">user=&gt; nil
nil
</code></pre>

<p>This is Clojure’s name for no-value, or null. It resolves to Java’s <code>null</code> value.</p>

<h3 id="strings">Strings</h3>

<p>Here is a Clojure string:</p>

<pre><code class="language-clojure">user=&gt; &quot;Hello, world!&quot;
&quot;Hello, world!&quot;
</code></pre>

<p>Clojure strings follow the same rules as Java strings, so for instance, <code>&quot;\t&quot;</code> represents the ASCII <code>TAB</code> character. The Java API is the primary way to make calculations on a string.</p>

<h3 id="symbols">Symbols</h3>

<p>Symbols are stand-in names for values. They&rsquo;re sort of like what you would call a constant in other languages. Clojure doesn&rsquo;t have variables. And unlike other languages, Clojure makes a distinction between a symbol and its value.</p>

<p>When a symbol is evaluated, its value is returned:</p>

<pre><code class="language-clojure">user=&gt; *file*
&quot;NO_SOURCE_PATH&quot;
user=&gt; *compile-path*
&quot;classes&quot;
user=&gt; *clojure-version*
{:major 1, :minor 3, :incremental 0, :qualifier nil}
user=&gt; *command-line-args*
nil
user=&gt; +
#&lt;core$_PLUS_ clojure.core$_PLUS_@6d581e80&gt;
</code></pre>

<p>The above shows some of Clojure&rsquo;s built-in symbols. By convention, built-in symbols begin and end with &lsquo;*&rsquo; if they bind to data. The last symbol shown &ldquo;+&rdquo; is a built-in function.</p>

<h3 id="keywords">Keywords</h3>

<p>Keywords are like symbols, except that they do not bind to an arbitrary value. They always bind to themselves. Keywords always start with a colon (<code>:</code>). Here are some keywords:</p>

<pre><code class="language-clojure">user=&gt; :a
:a
user=&gt; :_123
:_123
user=&gt; :KEY
:KEY
</code></pre>

<p><a name="lists"></a></p>

<h2 id="lists">Lists</h2>

<p>Near the beginning of the tutorial we saw a function call:</p>

<pre><code class="language-clojure">=&gt; (+ 3 3 3)
9
</code></pre>

<p>Function calls use lists to define the call. Lists are comprised of an opening and closing parenthesis, and zero or more elements. Each element is separated by whitespace or commas.</p>

<p>Lists can be both a data structure and a functional call form. When used as a function call, the first element of the lists is a function. Any remaining elements in the list are the function&rsquo;s arguments.</p>

<p>When a list is used to perform an operation, it is called a <em>form</em>. The function element of the form is referred to as the <em>operator</em>. Strictly, it isn&rsquo;t always a function. There are three kinds of forms: <em>functions</em>, <em>macros</em>, and <em>special forms</em>.</p>

<p>Although the list can be used to perform operations, it can also be used to represent data. There is an important consequence of code and data sharing the same syntax: code can be manipulated as if it were data because it <em>is</em> data.</p>

<p>One way to use lists simply as data is to use Clojure’s built-in operation, <code>list</code>:</p>

<pre><code class="language-clojure">user=&gt; (list 1 2 3)
(1 2 3)
user=&gt; (list a b c)
(a b c)
user=&gt; (list &quot;one&quot; &quot;two&quot; &quot;three&quot;)
(&quot;one&quot; &quot;two&quot; &quot;three&quot;)
</code></pre>

<p>List items can be atoms, other lists, or other data structures that are part of Clojure.</p>

<pre><code class="language-clojure">user=&gt; (list :foo (list 1 2 3) [4 5 6])
(:foo (1 2 3) [4 5 6])
</code></pre>

<p>Clojure also has a short-cut syntax for creating a list as data. Just prepend the list with a single-quote character:</p>

<pre><code class="language-clojure">user=&gt; '(1 2 3)
(1 2 3)
</code></pre>

<p>Creating a list this way has a slightly different effect. The list items are left unevaluated. They can be undefined, and Clojure won&rsquo;t complain.</p>

<p>Using some of Clojure’s built-in operations, information can be extracted from the data. The following expression returns the first element of the given list.</p>

<pre><code class="language-clojure">user=&gt; (first '(&quot;one&quot; &quot;two&quot; &quot;three&quot;))
&quot;one&quot;
</code></pre>

<p>Another operation returns all the elements except the first:</p>

<pre><code class="language-clojure">user=&gt; (rest '(&quot;one&quot; &quot;two&quot; &quot;three&quot;))
(&quot;two&quot; &quot;three&quot;)
</code></pre>

<p><a name="vectors"></a></p>

<h2 id="vectors">Vectors</h2>

<p>The vector is another data structure, similar to a list. Vectors are zero-based arrays. They can contain any value, and any mix of value types, just like lists. Here are a few examples:</p>

<pre><code class="language-clojure">user=&gt; [1 2 3]
[1 2 3]
user=&gt; [:a 0 &quot;hello&quot;]
[:a 0 &quot;hello&quot;]
user=&gt; []
[]
</code></pre>

<p>The nice thing about vectors is you don&rsquo;t have to do anything special to use them as data as you do with lists.</p>

<p>Other languages give you a handy syntax for getting an array&rsquo;s element by its index. So, how is this accomplished with Clojure&rsquo;s vectors? Perform an operation:</p>

<pre><code class="language-clojure">user=&gt; ([7 8 9] 2)
9
</code></pre>

<p>Here, we fetch the value at index <code>2</code>, which is <code>9</code>. The vector itself is the operator of the form. This may seem a little weird at first, but eventually it makes a lot of sense. Its argument is <code>2</code>. The general form for this operation is <code>(vector index)</code>. Compare this with JavaScript, which is similar:</p>

<pre><code class="language-javascript">[7, 8, 9][2]
</code></pre>

<p>You can use the same operation on vectors as we did earlier with lists:</p>

<pre><code class="language-clojure">user=&gt; (first [7 8 9])
7
user=&gt; (last [7 8 9])
9
user=&gt; (rest [7 8 9])
(8 9)
</code></pre>

<p>That last one was a bit unexpected. It didn&rsquo;t return a vector. It looks like a list instead.</p>

<p><a name="maps-sets"></a></p>

<h2 id="maps-and-sets">Maps and Sets</h2>

<p>In addition to lists as a data type, Clojure provides syntax for defining <em>maps</em> and <em>sets</em>.</p>

<p>Maps define a set of unique key-value pairs:</p>

<pre><code class="language-clojure">user=&gt; {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}
{&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}
</code></pre>

<p>The map above maps the string <code>&quot;a&quot;</code> to the number <code>1</code>, <code>&quot;b&quot;</code> to the number <code>2</code>, and <code>&quot;c&quot;</code> to the number <code>3</code>. The commas between each pair are optional, to enhance readability of the code. Clojure treats the commas nearly the same as whitespace. You can put commas anywhere between elements of an expression:</p>

<pre><code class="language-clojure">user=&gt; {&quot;a&quot; 1 &quot;b&quot; 2 &quot;c&quot; 3}
{&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}
user=&gt; {&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3}
{&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}
user=&gt; {&quot;a&quot;  1 ,&quot;b&quot; 2 ,&quot;c&quot; 3}
{&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}
</code></pre>

<p>Notice that Clojure REPL adds commas to the formatted return value.</p>

<p>Once a map is defined, its values can be looked up from key values using the <code>get</code> form:</p>

<pre><code class="language-clojure">user=&gt; (get {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;a&quot;)
1
user=&gt; (get {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;b&quot;)
2
user=&gt; (get {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;c&quot;)
3
user=&gt; (get {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;d&quot;)
nil
</code></pre>

<p>However, there’s a shortcut for this:</p>

<pre><code class="language-clojure">user=&gt; ({&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;a&quot;)
1
user=&gt; ({&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;b&quot;)
2
user=&gt; ({&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;c&quot;)
3
user=&gt; ({&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3} &quot;d&quot;)
nil
</code></pre>

<p>Similar to Vectors and lists, Maps can be used as functions of their keys.</p>

<p>There is yet a third way to get a value from a key:</p>

<pre><code class="language-clojure">user=&gt; (:a {:a 1, :b 2, :c 3})
1
user=&gt; (:b {:a 1, :b 2, :c 3})
2
user=&gt; (:c {:a 1, :b 2, :c 3})
3
user=&gt; (:d {:a 1, :b 2, :c 3})
nil
</code></pre>

<p>It’s important to get familiar with the last two usages, as they are commonly used in Clojure programs.</p>

<p><a name="defs"></a></p>

<h2 id="defining-variables-and-functions">Defining Variables and Functions</h2>

<h3 id="def"><code>def</code></h3>

<p>To bind a symbol to a value, use the <code>def</code> form:</p>

<pre><code class="language-clojure">user=&gt; (def x 5)
#'user/x
user=&gt; x
5
user=&gt; (+ 5 x)
10
user=&gt; (def my-list '(1 2 3))
#'user/my-list
user=&gt; my-list
(1 2 3)
user=&gt; (last my-list)
3
</code></pre>

<p>There a a few things going on when a variable is created. What gets returned from <code>def</code> is a <em>var</em>, which is a an object that holds a value, such as <em>5</em>. Also, a symbol is created, and that symbol is bound to the var.</p>

<h3 id="defn"><code>defn</code></h3>

<p>Functions can be created using <code>defn</code>:</p>

<pre><code class="language-clojure">user=&gt; (defn election-year? [year]
  (zero? (rem year 4)))
#'user/election-year?
user=&gt; (election-year? 2007)
false
user=&gt; (election-year? 2008)
true
user=&gt;
</code></pre>

<p>Functions are just a kind of object that can be called.</p>

<p>The first argument to a <code>defn</code> is the function’s name, which becomes a symbol bound to the function. The second argument is the function’s argument list. Argument lists are always represented by a vector. The remaining arguments of <code>defn</code> can be one or more expressions. The result of the last expression is used as the function’s return value.</p>

<h3 id="using-fn">Using <code>fn</code></h3>

<p>Anonymous functions can be created using <code>fn</code>:</p>

<pre><code class="language-clojure">user=&gt; (fn [x] (+ x 1))
user.eval__2384$fn__2386@c4b579
user=&gt; ((fn [x] (+ x 1)) 9)
10
</code></pre>

<p>Since functions are just objects, they can be bound to a symbol (assigned to a variable):</p>

<pre><code class="language-clojure">user=&gt; (def plus-one
     (fn [x] (+ x 1)))
#'user/plus-one
user=&gt; (plus-one 9)
10
</code></pre>

<p>The <code>defn</code> form is just a macro that turns its contents into a <code>def</code> + <code>fn</code> combination.</p>

<h3 id="the-doc-form">The <code>doc</code> form</h3>

<p>Nearly all the forms in Clojure have built-in documentation. To quickly find out about a form, pass the form’s name to the <code>doc</code> form:</p>

<pre><code class="language-clojure">user=&gt; (doc first)
-------------------------
clojure/first
([coll])
  Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.
nil
</code></pre>

<h3 id="documenting-a-function">Documenting a function</h3>

<p>There are multiple ways to add documentation to a function. Here is the easiest:</p>

<pre><code class="language-clojure">user=&gt; (defn plus-one
  &quot;Returns a number one greater than x&quot;
  [x]
  (+ x 1))
#'user/plus-one
user=&gt; (doc plus-one)
-------------------------
user/plus-one
([x])
  Returns a number one greater than x
nil
</code></pre>

<p>Here is another way:</p>

<pre><code class="language-clojure">user=&gt; (defn plus-one
  {:doc &quot;Returns a number one greater than x&quot;}
  [x]
  (+ x 1))
#'user/plus-one
user=&gt; (doc plus-one)
-------------------------
user/plus-one
([x])
  Returns a number one greater than x
nil
</code></pre>

<p><a name="special-forms"></a></p>

<h2 id="special-forms">Special Forms</h2>

<p>Clojure has several built-in forms, known collectively as <em>special forms</em>. This section introduces them and delves further into the types of expressions that are possible with Clojure.</p>

<h3 id="the-str-form">The <code>str</code> form:</h3>

<p>The <code>str</code> form concatenates two or more values, converting them to strings if necessary, and returns the result:</p>

<pre><code class="language-clojure">user=&gt; (str &quot;Hello,&quot; &quot; world!&quot;)
&quot;Hello, world!&quot;
user=&gt; (str 5)
&quot;5&quot;
user=&gt; (str &quot;Value: &quot; 5)
&quot;Value: 5&quot;
</code></pre>

<h3 id="the-if-form">The <code>if</code> form</h3>

<p>The <code>if</code> form is similar to the <code>if</code> statement in C-like languages.</p>

<pre><code class="language-clojure">user=&gt; (if true &quot;yes&quot;)
&quot;yes&quot;
user=&gt; (if false &quot;yes&quot;)
nil
user=&gt; (if false &quot;yes&quot; &quot;no&quot;)
&quot;no&quot;
user=&gt; (if nil &quot;yes&quot; &quot;no&quot;)
&quot;no&quot;
user=&gt; (if &quot;&quot; true)
true
user=&gt; (if 0 true)
true
user=&gt; (if true &quot;yes&quot; &quot;no&quot;)
&quot;yes&quot;
user=&gt; (if (= 1 1) &quot;yes&quot; &quot;no&quot;)
&quot;yes&quot;
user=&gt; (if (= 1 1) (+ 2 3) (+ 5 5))
5
user=&gt; (if (= 1 2) (+ 2 3) (+ 5 5))
10
</code></pre>

<p>If the first argument, converted to a boolean, is true, then the second argument is returned. Otherwise the third argument is returned. The third argument is optional.</p>

<p>In Clojure, when a value is converted to boolean, it is always <span class="caps">TRUE</span>, unless the value is <code>false</code> or <code>nil</code>. There are many forms that make decisions based on whether a value will be true or false when converted to boolean.</p>

<p>The <code>if</code> form works a lot like the C-language ternary operator:</p>

<pre><code class="language-clojure">v = true ? 1 : 0
</code></pre>

<p>The ternary operator is usually used in places where an <code>if</code> statement is too verbose. However, since Clojure’s <code>if</code> form is already succinct, there is no need for a separate operator. You can still break up the expression onto separate lines when it makes sense to do so:</p>

<pre><code class="language-clojure">user=&gt; (if (= 1 1)
  (+ 2 3)
  (+ 3 4))
5
user=&gt; (if (= &quot;foobar&quot; (str &quot;foo&quot; &quot;bar&quot;))
  &quot;'foo' plus 'bar' equals 'foobar'&quot;
  &quot;'foo' plus 'bar' does not equal 'foobar'&quot;)
&quot;'foo' plus 'bar' equals 'foobar'&quot;
</code></pre>

<h3 id="the-do-form">The <code>do</code> form:</h3>

<p>The <code>do</code> form is used to execute a number of operations in sequence. Typically in functional programming, expressions are contained by, or are containers for, other expressions, so there isn’t a need to execute operations one after the other. This is fine when the expressions produce a value that will be used by a containing expression. However, there are some occasions where the value of an expression isn’t used. If such an expression does anything useful at all, it is said to have side effects. For example, writing something to standard output, or a file, or a database, are all examples of side-effects.</p>

<p>Clojure provides the <code>println</code> form for writing to standard output. In order to use <code>println</code> within an expression whose return value we care about, we need to put it in a <code>do</code> expression:</p>

<pre><code class="language-clojure">user=&gt; (do (println &quot;Hello.&quot;) (+ 2 2))
Hello.
4
user=&gt; (do (println &quot;Hello.&quot;) (println &quot;Hello again.&quot;) (+ 2 2))
Hello.
Hello again.
4
</code></pre>

<p>The <code>do</code> operation executes each expression in sequence and returns the result of the last expression.</p>

<p>The <code>do</code> form isn’t the only form that lets you perform a number of operations in sequence. <code>let</code>, <code>defn</code> and <code>fn</code> all let you do that too.</p>

<p>One of the things that takes some getting used to is that Clojure is a functional language. All expressions in Clojure return a value. Often, a single Clojure expression will span several lines, where the C-like programmer would write it out the same logic as a block of code consisting of several distinct statements. The distinct statements may assign a value to a variable to be used in the following statements. Programs written in functional languages tend to have larger statements spanning multiple lines rather than a multiline block of code split into smaller statements. This way of building programs can take some getting used to, but once you’ve learned it, the new way can be just as easy as the old. There are several advantages to writing programs this way.</p>

<h3 id="the-when-form">The <code>when</code> form</h3>

<p>The <code>when</code> form is similar to the <code>if</code> form. The differences are that there is no “else” condition, and more than one expression can be added to the <code>when</code> form for evaluation when the condition is <span class="caps">TRUE</span>.</p>

<pre><code class="language-clojure">user=&gt; (when nil &quot;Should return 'nil'&quot;)
nil
user=&gt; (when false &quot;Should return 'nil'&quot;)
nil
user=&gt; (when true &quot;Yes&quot;)
&quot;Yes&quot;
user=&gt; (when true 1)
1
user=&gt; (when true 1 2 3)
3
user=&gt; (when true
  (println &quot;Hello, world&quot;)
  &quot;Yes&quot;)
Hello, world
&quot;Yes&quot;
user=&gt; (when (= 5 (inc 4))
  &quot;Yes&quot;)
&quot;Yes&quot;
</code></pre>

<h3 id="the-let-form">The <code>let</code> form</h3>

<p>The <code>let</code> operator is used for setting up and holding temporary values to be used by a containing operation.</p>

<pre><code class="language-clojure">user=&gt; (let [x 2] (+ x 8))
10
user=&gt; (let [x 2 y 8] (+ x y))
10
user=&gt; (let [x 2 y 8] (= (+ x y) 10))
true
user=&gt; (let [x 3] (+ (* x x) 1))
10
user=&gt; (let [color &quot;Red&quot;] (str &quot;Color is: &quot; color))
&quot;Color is: Red&quot;
user=&gt; (let [color &quot;Red&quot; phrase (str &quot;Color is: &quot; color)]
  (str &quot;Clojure says: &quot; phrase))
&quot;Clojure says: Color is: Red&quot;
</code></pre>

<p>The <code>let</code> form creates a temporary var (<code>x</code> and <code>y</code> in this case), that can only be used inside the body of the <code>let</code> expression. A vector is used to define the var and its value, and vectors are also used by other Clojure forms to declare a list of temporary variables and their assigned values. The vector contains name-value pairs.</p>

<p><a name="looping-iterating"></a></p>

<h2 id="looping-and-iterating">Looping and Iterating</h2>

<p>Here are three ways to loop while incrementing an index from 0 to 4 (5 iterations):</p>

<pre><code class="language-clojure">user=&gt; (loop [i 0]
  (when (&lt; i 5)
    (println i)
    (recur (inc i))))
0
1
2
3
4
nil
user=&gt; (dorun (for [i (range 0 5)]
         (println i)))
0
1
2
3
4
nil
user=&gt; (doseq [i (range 0 5)]
  (println i))
0
1
2
3
4
nil
</code></pre>

<p>The first example uses the <code>loop</code> form, which provides the most flexibility, but requires the most syntactical overhead. The second and third examples are examples of iterating over a sequence, which is a more common kind of looping. The <code>dorun</code> and <code>doseq</code> calls suppress the return values of the containing expressions.</p>

<p>Let’s look at the <code>loop</code> form a little closer.</p>

<pre><code class="language-clojure">user=&gt; (loop [i 0]
  (when (&lt; i 5)
    (println &quot;i:&quot; i)
    (recur (inc i))))
i: 0
i: 1
i: 2
i: 3
i: 4
nil
</code></pre>

<p>In the above example, the temporary symbol <code>i</code> is bound to a value of <code>0</code>. The <code>when</code> statement checks to see if <code>i</code> is less than <code>5</code>. If the test passes, the two expressions inside are evaluated. The <code>println</code> expression outputs the value of <code>i</code>. Next, the <code>recur</code> form is evaluated, which instructs the loop to iterate again with a new value for <code>i</code>. The <code>(inc i)</code> is short for <code>(+ i 1)</code>.</p>

<p>Without the <code>recur</code>, a <code>loop</code> expression behaves exactly the same as a <code>let</code> expression.</p>

<p><a name="sequences"></a></p>

<h2 id="sequences">Sequences</h2>

<p>Sequences are in a sense, the core of idiomatic Clojure programming. Understand sequences and the forms that work with them, and you will have cleared one of the biggest hurdles to writing significant Clojure programs.</p>

<p>At first glance, a Sequence looks like another data structure. However, a Sequence is not a data structure. It is an interface, or view, into a data structure. A sequence can be derived from a collection. The relation between collection and sequence is similar to the relation between database table and database view.</p>

<p><a href="http://clojure.org/sequences">Clojure’s section on Sequences</a> gives an excellent definition.</p>

<p>Let’s get a sequence from a vector:</p>

<pre><code class="language-clojure">user=&gt; (seq [1 2 3])
(1 2 3)
</code></pre>

<p>This bit of code doesn’t merely convert the vector into a list. It calls on the vector to produce a sequence of the vector. The <span class="caps">REPL</span> (Read, Evaluate, Print, Loop), as part of its ‘Print’ step, uses the sequence to produce a list so that something meaningful can be displayed.</p>

<p>One way to keep the <span class="caps">REPL</span> from creating a list from the sequence is to enclose the expression in another expression that doesn’t consume the sequence. For example, a method call of the sequence will not consume the sequence. Take <code>getClass()</code> for instance:</p>

<pre><code class="language-clojure">user=&gt; (.getClass (seq [1 2 3]))
clojure.lang.APersistentVector$Seq
</code></pre>

<p>What gets returned is an APersistentVector$Seq, which is the class that represents a vector’s sequence.</p>

<p>All of Clojure’s built-in data structures have methods to produce a sequence. The sequence interface is formally named clojure.lang.iSeq, or iSeq.</p>

<h3 id="first"><code>first</code></h3>

<p>Use <code>first</code> to get the first item in a sequence:</p>

<pre><code class="language-clojure">user=&gt; (first (seq [1 2 3]))
1
</code></pre>

<p><code>first</code> will also take a vector directly, implicitly converting it into a sequence:</p>

<pre><code class="language-clojure">user=&gt; (first [1 2 3])
1
user=&gt; (first [&quot;a&quot; &quot;b&quot; &quot;c&quot;])
&quot;a&quot;
user=&gt; (first '(&quot;A&quot; &quot;B&quot; &quot;C&quot;))
&quot;A&quot;
user=&gt; (first '(:a :b :c))
:a
</code></pre>

<p>Most of the sequence forms do this implicit conversion, so you can pass any collection that provides an iSeq interface, including any of Clojure’s built-in collection types.</p>

<h3 id="rest"><code>rest</code></h3>

<p><code>rest</code> produces a sequence that consists of every item of the original sequence, minus the first item.</p>

<pre><code class="language-clojure">user=&gt; (rest [1 2 3])
(2 3)
user=&gt; (rest [&quot;a&quot; &quot;b&quot; &quot;c&quot;])
(&quot;b&quot; &quot;c&quot;)
user=&gt; (rest '(&quot;A&quot; &quot;B&quot; &quot;C&quot;))
(&quot;B&quot; &quot;C&quot;)
user=&gt; (rest [:a :b :c])
(:b :c)
</code></pre>

<p>Keep in mind that no new data structure is created. <code>rest</code> only creates a logical list (a sequence). It is up to the caller to create a data structure, if needed. In the examples above, the caller is the <span class="caps">REPL</span>, and it collects the sequence into a list so that it can display something meaningful. It is computationally inexpensive to create a sequence.</p>

<h3 id="cons"><code>cons</code></h3>

<p><code>cons</code> creates a new sequence by prepending an element onto a collection. The element is the first argument, and the collection is the second.</p>

<pre><code class="language-clojure">user=&gt; (cons 1 [2 3])
(1 2 3)
user=&gt; (cons :a [:b :c])
(:a :b :c)
</code></pre>

<p>Again, no data structure is created by <code>cons</code>. The resulting sequence internally consists of separate pointers to the first and second arguments of <code>cons</code>. To the user or consumer of the sequence, it appears as one continuous sequence.</p>

<p><a name="java-integration"></a></p>

<h2 id="java-integration">Java Integration</h2>

<p>Clojure provides the ability to interface with Java objects and primitives. Knowing how to do this is essential for non-trival programs.</p>

<p>Let’s start by instantiating a Java <code>java.util.Date</code> object:</p>

<pre><code class="language-clojure">user=&gt; (new java.util.Date)
Mon May 26 10:25:25 PDT 2008
</code></pre>

<p>Clojure instantiates the <code>Date</code> object, then calls and displays its <code>toString()</code> method as a visual representation of the object.</p>

<p>To pass arguments to the object’s constructor, just include them in the call to <code>new</code>:</p>

<pre><code class="language-clojure">user=&gt; (new StringBuffer &quot;This is the initial value&quot;)
This is the initial value
</code></pre>

<p>There is also a shortcut syntax for instantiation. Replace the <code>new</code> operator and the Java class with only the Java class, but with a period appended to its name:</p>

<pre><code class="language-clojure">user=&gt; (StringBuffer. &quot;This is the initial value&quot;)
This is the initial value
</code></pre>

<p>To call a method on an instance, use the special dot-method (<code>.&lt;method&gt;</code>) form. The operator in this form consists of the method name, prepended with a period. The second argument is the object whose method is called:</p>

<pre><code class="language-clojure">(.toString (new java.util.Date))
&quot;Thu Apr 05 21:44:36 PDT 2012&quot;
(.toString (java.util.Date.))
&quot;Thu Apr 05 21:45:22 PDT 2012&quot;
</code></pre>

<p>After the operator and object, any additional arguments are passed as arguments to the method:</p>

<pre><code class="language-clojure">user=&gt; (def my-hash (java.util.HashMap.))
#'user/my-hash
user=&gt; (.put my-hash &quot;food&quot; &quot;tacos&quot;)
nil
user=&gt; (.get my-hash &quot;food&quot;)
&quot;tacos&quot;
</code></pre>

<p>Above, a <code>symbol</code> called <code>my-hash</code> is created and bound to a HashMap instance. Then a value is added to the HashMap for the key <code>&quot;food&quot;</code>. Then the value is retrieved from the HashMap.</p>

<p>Static (class) fields and methods are called with a different syntax:</p>

<pre><code class="language-clojure">user=&gt; (Integer/MAX_VALUE)
2147483647
user=&gt; (Character/TYPE)
char
user=&gt; (Boolean/valueOf &quot;true&quot;)
true
</code></pre>

<p>Just like with Java, Clojure provides the means to import classes into the current context, so that classes do not need to be written out using the fully-qualified syntax:</p>

<pre><code class="language-clojure">user=&gt; (import '(java.io FileReader))
nil
user=&gt; (FileReader. &quot;source.txt&quot;)
java.io.FileReader@f784d7
</code></pre>

<p>Multiple classes within a package can be included, like this:</p>

<pre><code class="language-clojure">user=&gt; (import '(java.io File FileReader))
nil
</code></pre>

<p>Both the <code>File</code> and <code>FileReader</code> classes are</p>

<p>imported above.</p>

<p>If the classes are in different packages, use this syntax:</p>

<pre><code class="language-clojure">user=&gt; (import '(java.io File) '(java.util HashMap))
nil
</code></pre>

<p>Or you can use two separate import statements:</p>

<pre><code class="language-clojure">user=&gt; (import '(java.io File))
nil
user=&gt; (import '(java.util HashMap))
</code></pre>

<p><a name="libraries"></a></p>

<h2 id="using-clojure-libraries">Using Clojure Libraries</h2>

<p>If you&rsquo;re writing an application, you&rsquo;ll probably end up using a third party library.</p>

<h3 id="leiningen">Leiningen</h3>

<p>The ideal way to import libraries is to use a packaging tool called Leiningen.</p>

<p>First, <a href="https://github.com/technomancy/leiningen/">install Leiningen</a>. In order to do its job, Leiningen needs to create a new project directory for your project:</p>

<pre><code class="language-bash">&gt; lein new my-project
</code></pre>

<p>In the new project directory, it puts a file, <code>project.clj</code> that represents your project to Leiningen. Go ahead an edit this file, changing the project description to match your tastes.</p>

<p>There are two main repositories for Clojure libraries: <a href="http://dev.clojure.org/display/doc/Clojure+Contrib">Clojure Contrib</a>, and <a href="https://clojars.org/">Clojars</a>. We&rsquo;ll look at Clojure Contrib.</p>

<h3 id="clojure-contrib">Clojure Contrib</h3>

<p>The libraries in Clojure Contrib can be found at <a href="http://dev.clojure.org/display/doc/Clojure+Contrib">the Clojure Contrib libraries list</a>. Choose a library to use. For this tutorial, we&rsquo;ll use <code>data.json</code>.</p>

<p>Edit your <code>project.clj</code> file. Add a new vector to the <code>:dependencies</code> vector. This new vector will contain two elements:</p>

<pre><code class="language-clojure">[org.clojure/data.json &quot;0.1.2&quot;]
</code></pre>

<p>For Clojure Contrib libraries and any other libraries associated with the Clojure project, the dependency path with start with <code>org.clojure/</code>, followed by the library name, <code>data.json</code></p>

<p>So now, the <code>:dependencies</code> vector will look something like this:</p>

<pre><code class="language-clojure">:dependencies [[org.clojure/clojure &quot;1.4.0&quot;]
               [org.clojure/data.json &quot;0.1.2&quot;]]
</code></pre>

<p>When using Leiningen for your project, you need to use lein to get to the REPL:</p>

<pre><code class="language-bash">&gt; lein repl
REPL started; server listening on localhost port 64984
user=&gt;
</code></pre>

<p>Now the library can be referenced from your code:</p>

<pre><code class="language-clojure">user=&gt; (use '[clojure.data.json :only (read-json json-str)])
nil
user=&gt; (json-str {:color &quot;red&quot; :name &quot;apple&quot;})
&quot;{\&quot;name\&quot;:\&quot;apple\&quot;,\&quot;color\&quot;:\&quot;red\&quot;}&quot;
user=&gt; (read-json &quot;{\&quot;width\&quot;: 300, \&quot;height\&quot;: 200}&quot;)
{:width 300, :height 200}
</code></pre>

<p><a name="resources"></a></p>

<h2 id="additional-resources">Additional Resources</h2>

<ul>
<li><a href="http://clojuredocs.org/">ClojureDocs: http://clojuredocs.org/</a></li>
<li><a href="http://en.wikibooks.org/wiki/Clojure_Programming">Clojure Programming Wikibook: http://en.wikibooks.org/wiki/Clojure_Programming</a></li>
</ul>

</article>

		</main>
		
				<div class="hide-print sans-serif f6 f5-l mt5 ph3 pb6 center nested-copy-line-height lh-copy nested-links mw-100 measure-wide">
		<div class="about-the-author">
		
			
			
				
					
				
			
		
		</div>
		
	</div>

		
		
		
		<footer class="hide-print sans-serif f6 fw1 bg-black near-white bottom-0 w-100 pa3" role="contentinfo">
			<p class="w-50 fr tr">
			<a class="no-underline near-white" href="https://github.com/xaprb/story"><img class="dib" title="Made with Hugo and Story" alt="Story logo" src="http://www.moxleystratton.com/img/story-logo-white.svg" style="width: 1.5rem; height: 1.5rem" /></a>
			</p>
			<p class="w-50 near-white">
				&copy; 2018 
			</p>
		</footer>
		
	
	
	</body>
</html>
