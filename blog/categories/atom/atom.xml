<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Atom | Moxley Stratton]]></title>
  <link href="http://www.moxleystratton.com/blog/categories/atom/atom.xml" rel="self"/>
  <link href="http://www.moxleystratton.com/"/>
  <updated>2018-02-05T09:54:32-08:00</updated>
  <id>http://www.moxleystratton.com/</id>
  <author>
    <name><![CDATA[Moxley Stratton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Atom Editor Setup for Elixir]]></title>
    <link href="http://www.moxleystratton.com/blog/2018/02/05/atom-elixir-setup/"/>
    <updated>2018-02-05T09:02:41-08:00</updated>
    <id>http://www.moxleystratton.com/blog/2018/02/05/atom-elixir-setup</id>
    <content type="html"><![CDATA[<p>I use the following Atom plugins for Elixir:</p>

<ul>
<li>language-elixir</li>
<li>linter-elixirc</li>
<li>linter-elixir-credo</li>
<li>atom-elixir-formatter</li>
</ul>


<p>After installing each of these packages, make sure you configure them. Most of
them don&rsquo;t work without explicit configuration.</p>

<p>Most of these plugins require you to configure either the <code>elixir</code> binary path
or the <code>mix</code> binary path (or both). To do so, first open a terminal, and run
<code>which elixir</code> or <code>which mix</code> to get the binary path.</p>

<h2>language-elixir</h2>

<p>This is the minimal package you want to use when developing Elixir code.
It provides code syntax highlighting.</p>

<h2>linter-elixirc</h2>

<p>This provides feedback when you write bad syntax or syntax that is considered a
warning by the Elixir compiler. It saves time that would be wasted running
tests, only to find out you wrote bad syntax.</p>

<h2>linter-elixir-credo</h2>

<p>This provides feedback when you write syntax that violates code style conventions
managed by Credo.</p>

<h2>atom-elixir-formatter</h2>

<p>Utility that formats Elixir code with the Elixir Formatter. One side utility of
this package is that it allows you to paste in large data structures from test
output into your test or fixtures, then easily format the resulting code. It
only works if you have Elixir 1.6 or higher.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Considering a Switch to the Atom Text Editor?]]></title>
    <link href="http://www.moxleystratton.com/blog/2014/03/16/considering-a-switch-to-the-atom-text-editor/"/>
    <updated>2014-03-16T12:00:00-07:00</updated>
    <id>http://www.moxleystratton.com/blog/2014/03/16/considering-a-switch-to-the-atom-text-editor</id>
    <content type="html"><![CDATA[<p>You&rsquo;ve probably heard of <a href="http://atom.io/">Atom, Github&rsquo;s new text editor</a>. Read
these checklists to help you decide whether it&rsquo;s an editor worth switching to.</p>

<!-- more -->


<h2>General Pros</h2>

<ul>
<li>Open Source</li>
<li>High-quality extension and enhancement infrastructure</li>
<li>View is programmable using good old HTML DOM and CSS</li>
<li>Well-known API model (NodeJS)</li>
<li>Built-in Github integration</li>
<li>Built-in, light Git integration</li>
<li><a href="https://www.youtube.com/watch?v=VGUemwCaBR0&amp;amp;feature=youtu.be">Realtime Markdown preview</a></li>
<li>Seamlessly tracks external file renames while the file is open</li>
<li>Browse archive files, like zip or tar.gz, like Emacs does.</li>
<li>UI and editing features basically a clone of Sublime Text</li>
<li>Free, while in Beta.</li>
</ul>


<h2>General Cons</h2>

<ul>
<li>In Beta. Some rough UX details.</li>
<li>No keyboard macros</li>
<li>No command documentation</li>
<li>Difficult to discover available commands</li>
<li>Currently only works on OS X (Windows and Linux planned)</li>
</ul>


<h2>For Sublime Users</h2>

<h3>Pros</h3>

<ul>
<li>Package manager is built in</li>
<li>Deep customization API</li>
<li>Fine-grained commands</li>
<li>Complete pane splitting and pane navigation</li>
<li>Smarter indentation of pasted text</li>
</ul>


<h3>Cons</h3>

<ul>
<li>2-3x slower, 2-3x more memory than ST3 (realistically, it&rsquo;s not as bad as it sounds)</li>
<li>No &ldquo;Jump Back&rdquo; feature, as found in ST3</li>
<li>No auto-highlighting matching strings of selected string</li>
<li>Can&rsquo;t open file in existing window, unless it lives within the window&rsquo;s directory</li>
<li>Missing key bindings for many search &amp; replace operations</li>
</ul>


<h2>For Vim and Emacs Users</h2>

<h3>Pros</h3>

<ul>
<li>Modern Application and UI, contemporary key bindings</li>
<li>Easy to learn</li>
<li>Built in Package manager, and standard package formats</li>
<li>View is good old HTML DOM, CSS</li>
<li>CoffeeScript is arguably better than eLisp and Vimscript</li>
<li>Editor API reaches deep into the editor</li>
<li>Project-wide fuzzy file finder, built in, fuss-free</li>
<li>Buffer-wide fuzzy symbol finder, built in, fuss-free</li>
<li>Project-wide string search</li>
<li>Large number of homerow-close key bindings (many of them are Emacs compatible)</li>
<li>Pane splitting on par with Vim and Emacs</li>
<li>Multi selections</li>
<li>Code Snippets</li>
</ul>


<h3>Cons</h3>

<ul>
<li>Editor API doesn&rsquo;t go as deep as Emacs. Lacks rich callback API that Emacs has.</li>
<li>No cursor history, so no command for going back to the last location without using bookmarks</li>
<li>No cursor navigation around, or editing operations on, symbol definitions (e.g., methods)</li>
<li>Unlike Emacs, no built-in shell console (package under development)</li>
<li>Keyboard navigation of file tree is cumbersome, but will likely improve over time.</li>
<li>Missing a lot of the cool text navigation and editing commands available to Vim and Emacs</li>
</ul>

]]></content>
  </entry>
  
</feed>
