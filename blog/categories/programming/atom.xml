<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming, | Moxley Stratton]]></title>
  <link href="http://www.moxleystratton.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://www.moxleystratton.com/"/>
  <updated>2015-09-27T13:27:40-07:00</updated>
  <id>http://www.moxleystratton.com/</id>
  <author>
    <name><![CDATA[Moxley Stratton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Low-Level ActiveRecord]]></title>
    <link href="http://www.moxleystratton.com/blog/2015/09/27/low-level-activerecord/"/>
    <updated>2015-09-27T10:58:40-07:00</updated>
    <id>http://www.moxleystratton.com/blog/2015/09/27/low-level-activerecord</id>
    <content type="html"><![CDATA[<p>With most large Rails projects, there is a need to bypass the normal ActiveRecord
API, and get closer to the low-level SQL API. Here are a few useful methods
for unlocking the confines of everyday ActiveRecord.</p>

<h3>#find_by_sql</h3>

<pre><code class="ruby">users = User.find_by_sql("SELECT * FROM users WHERE id = 1")
</code></pre>

<p>This returns model instances for the given SQL string.</p>

<p><code>#find_by_sql</code> also accepts parametrized values, like this:</p>

<pre><code class="ruby">users = User.find_by_sql(["SELECT * FROM users WHERE id = ?", 1])
</code></pre>

<h3>#select_all</h3>

<pre><code class="ruby">users = ActiveRecord::Base.connection.select_all("
  SELECT first_name, created_at
  FROM users
  WHERE id = 1")
</code></pre>

<p>This returns an array-like object of type <code>ActiveRecord::Result</code>. Each item in
the collection is a <code>Hash</code> representing a row in the results.</p>

<p>The <code>ActiveRecord::Result</code> contains information about the table and its columns.
It knows how to convert column values to their corresponding Ruby types.</p>

<h3>#execute</h3>

<pre><code class="ruby">ActiveRecord::Base.connection.execute("SELECT * FROM users WHERE id=1")
</code></pre>

<p>This returns an array-like object that is specific on the database driver. For
PostgreSQL, this will be a <code>PG::Result</code>. Each item in the collection is a
<code>Hash</code>. The values of the Hash are strings and nils. No conversion is performed
to convert the values to the appropriate Ruby type, other than NULL to nil.</p>

<h3>#quote</h3>

<p>The <code>select_all</code> and <code>execute</code> methods have no built-in mechanism for escaping
values for the SQL statement.</p>

<p>Something like this is bad practice:</p>

<pre><code class="ruby">users = ActiveRecord::Base.connection.select_all("
  SELECT * FROM users WHERE email='#{email}'")
</code></pre>

<p>Because we&rsquo;re not sure what is in <code>email</code>. It could have an SQL injection
attack, or it could just have unexpected characters that will break
the query. To cover these
cases, ActiveRecord provides <code>#quote</code>:</p>

<pre><code class="ruby">conn = ActiveRecord::Base.connection
users = conn.select_all("
  SELECT * FROM users WHERE email='#{conn.quote(email)}'")
</code></pre>

<h3>#sanitize_sql_array</h3>

<p>Using <code>#quote</code> can get unwieldy as more and more values need to be escaped.
There is a private method called <code>#sanitize_sql_array</code> that brings back the
parameterized escape mechanism that is present in ActiveRecord&rsquo;s higher-level
API.</p>

<pre><code class="ruby">sql = ActiveRecord::Base.send(:sanitize_sql_array,
  ["SELECT * FROM users WHERE email=?", email])

users = ActiveRecord::Base.connection.select_all(sql)
</code></pre>

<h3>#connection_config</h3>

<p>Sometimes you need to introspect the database connection details. Maybe you have an external utility that performs bulk operations against the database, and
it bypasses ActiveRecord entirely.</p>

<pre><code class="ruby">config = Rails.application.config.database_configuration

{
  "common" =&gt; {
    "adapter"           =&gt; "postgres",
    "encoding"          =&gt; "utf8",
    "postgis_extension" =&gt; true,
    "username"          =&gt; "user",
    "password"          =&gt; "password",
    "host"              =&gt; "127.0.0.1",
    "port"              =&gt; 5432
  },
  "development" =&gt; {
    "adapter"           =&gt; "postgres",
    "encoding"          =&gt; "utf8",
    "postgis_extension" =&gt; true,
    "username"          =&gt; "user",
    "password"          =&gt; "password",
    "host"              =&gt; "127.0.0.1",
    "port"              =&gt; 5432,
    "database"          =&gt; "database_development"    
  },
  "production" =&gt; {
    "adapter"           =&gt; "postgres",
    "encoding"          =&gt; "utf8",
    "postgis_extension" =&gt; true,
    "username"          =&gt; "user",
    "password"          =&gt; "password",
    "host"              =&gt; "127.0.0.1",
    "port"              =&gt; 5432,
    "database"          =&gt; "database_production"    
  }
}
</code></pre>

<h2>#structure_load</h2>

<p>For times when you need to load a bunch of SQL statements from a file,
ActiveRecord profiles <code>#structure_load</code>.</p>

<pre><code class="ruby">config = Rails.application.config.database_configuration['development']
sql_file = "tmp/foo.sql"
ActiveRecord::Tasks::DatabaseTasks.structure_load(config, sql_file)
</code></pre>
]]></content>
  </entry>
  
</feed>
