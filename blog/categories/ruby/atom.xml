<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Moxley Stratton]]></title>
  <link href="http://moxley.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://moxley.github.io/"/>
  <updated>2014-11-29T15:13:01-08:00</updated>
  <id>http://moxley.github.io/</id>
  <author>
    <name><![CDATA[Moxley Stratton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sometimes Clojure Is More Concise Than Ruby]]></title>
    <link href="http://moxley.github.io/blog/2014/11/24/sometimes-clojure-is-more-concise-than-ruby/"/>
    <updated>2014-11-24T19:00:00-08:00</updated>
    <id>http://moxley.github.io/blog/2014/11/24/sometimes-clojure-is-more-concise-than-ruby</id>
    <content type="html"><![CDATA[<p>I find that 90% of the time, Clojure is more verbose than Ruby. Here&rsquo;s one simple example where Clojure wins a conciseness battle:</p>

<pre><code class="clojure">;; Subtract two vectors in Clojure
(def a [10 9 8])
(def b [1 2 3])
(map - a b)
;; (9 7 5)
</code></pre>

<pre><code class="ruby"># Subtract two vectors in Ruby
a = [10, 9, 8]
b = [1, 2, 3]
a.zip(b).map { |(a, b)| a - b }
# [9, 7, 5]
</code></pre>

<p>What is it about Ruby that makes it less concise in this example?</p>

<p>In my opinion, the OOP nature of Ruby gets in the way. In OOP, there is a message receiver
(the object), plus zero or more arguments. In Clojure, there is no receiver, only arguments.
In Ruby, the two arguments to Clojure&rsquo;s <code>map</code> call have to be split up into the receiver
and the first argument. Additionally, the arguments to Ruby&rsquo;s <code>map</code> arrive as a single
array instead of of two distinct scalar arguments. This requires the destructor
parentheses inside the <code>map</code> block.</p>

<p>The syntactical division between a receiver and it&rsquo;s arguments is usually not a problem.
But every once in a while, it gets in the way. Another division in OOP is between class
and instance. I&rsquo;ve found that this division can sometimes get in the way too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding the Source for a Given Rails Web Page]]></title>
    <link href="http://moxley.github.io/blog/2014/05/29/finding-the-source-for-a-given-rails-web-page/"/>
    <updated>2014-05-29T12:00:00-07:00</updated>
    <id>http://moxley.github.io/blog/2014/05/29/finding-the-source-for-a-given-rails-web-page</id>
    <content type="html"><![CDATA[<p>These tips may help those of you who are relatively new to Rails, or maybe even if you&rsquo;re not.</p>

<!-- more -->


<h2>Common tips and tricks</h2>

<ul>
<li>Look at the URL path (e.g. <code>/users/100685/edit</code>).
Can the action and main view file be determined from CRUD/REST conventions?

<ul>
<li><code>/:model/edit</code> -> edit.html.slim</li>
<li><code>/:model/1234</code> -> show.html.slim</li>
<li><code>/:model/new</code> -> new.html.slim</li>
<li><code>/:model</code> -> index.html.slim</li>
</ul>
</li>
<li>Look up the path in routes.rb, or even more useful, run <code>rake routes</code></li>
</ul>


<h2>Finding a controller and action responsible for a given page</h2>

<ol>
<li>In development go to your server&rsquo;s output, and clear the screen (<code>Ctrl+L</code>,
for Linux, <code>Cmd-K</code> for OS X)</li>
<li>Refresh the web page</li>
<li>Back to the server&rsquo;s output, scroll to the top of the output. About the second
line of non-blank log output, you should see something like:
<code>Processing by UserseController#edit as HTML</code>. That&rsquo;s the
controller (<code>UsersController</code>) and action (<code>edit</code>).</li>
</ol>


<h2>Finding a view file for a given page</h2>

<ul>
<li>If in development, look at the server log. If it is too noisy, use
<code>tail -f log/development | grep Rendered</code> to cut out the noise.</li>
<li>If in development, add the <code>rails_view_annotator</code> gem to your Gemfile,
and look at the DOM or HTML source. It should have HTML comments identifying
the view partials responsible for their generated HTML.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Escape, Unescape, Encode, Decode, HTML, XML, URI, URL]]></title>
    <link href="http://moxley.github.io/blog/2007/07/31/ruby-escape-unescape-encode-decode-html-xml-uri-url/"/>
    <updated>2007-07-31T12:00:00-07:00</updated>
    <id>http://moxley.github.io/blog/2007/07/31/ruby-escape-unescape-encode-decode-html-xml-uri-url</id>
    <content type="html"><![CDATA[<p>This example shows you how to escape and un-escape a value to be included in a URI and within HTML.</p>

<!-- more -->


<pre><code class="ruby">require 'cgi'

# Escape data for URL query parameters
name = "ruby?"
value = "yes"
url = "http://example.com/?" + CGI.escape(name) + '=' + CGI.escape(value) + "&amp;var=T"
# url: http://example.com/?ruby%3F=yes&amp;var=T

# Escape data for HTML
url = "http://example.com/?ruby%3F=yes&amp;var=T"
html = %(&lt;a href="#{CGI.escapeHTML(url)}"&gt;example&lt;/a&gt;)
# html: &lt;a href="http://example.com/?ruby%3F=yes&amp;amp;var=T"&gt;example&lt;/a&gt;

# Unescape HTML-escaped data
url = CGI.unescapeHTML("http://example.com/?ruby%3F=yes&amp;amp;var=T")
# url: http://example.com/?ruby%3F=yes&amp;var=T

# Parse query params:
query = "ruby%3F=yes&amp;var=T"
pairs = query.split('&amp;')    # pairs: ["ruby%3F=yes", "var=T"]
name, value = pairs[0].split('=').map{|v| CGI.unescape(v)}
# name, value: ["ruby?", "yes"]
</code></pre>
]]></content>
  </entry>
  
</feed>
