<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Moxley Stratton]]></title>
  <link href="http://www.moxleystratton.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://www.moxleystratton.com/"/>
  <updated>2017-08-09T09:55:46-07:00</updated>
  <id>http://www.moxleystratton.com/</id>
  <author>
    <name><![CDATA[Moxley Stratton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Low-Level ActiveRecord]]></title>
    <link href="http://www.moxleystratton.com/blog/2015/09/27/low-level-activerecord/"/>
    <updated>2015-09-27T10:58:40-07:00</updated>
    <id>http://www.moxleystratton.com/blog/2015/09/27/low-level-activerecord</id>
    <content type="html"><![CDATA[<p>With many Rails projects, there is occasionally a need to bypass the normal
ActiveRecord API, and get closer to the low-level SQL API. Here are a few
useful methods that bypass the confines of everyday ActiveRecord.</p>

<h3>#find_by_sql</h3>

<pre><code class="ruby">users = User.find_by_sql("SELECT * FROM users WHERE id = 1")
</code></pre>

<p>This returns model instances for the given SQL string.</p>

<p><code>#find_by_sql</code> also accepts parametrized values, like this:</p>

<pre><code class="ruby">users = User.find_by_sql(["SELECT * FROM users WHERE id = ?", 1])
</code></pre>

<h3>#select_all</h3>

<pre><code class="ruby">users = ActiveRecord::Base.connection.select_all("
  SELECT id, first_name, created_at
  FROM users
  WHERE id = 1")

users[0]
{
  "id"         =&gt; 202,
  "first_name" =&gt; "Trystan",
  "created_at" =&gt; "2015-09-05 15:44:51.597326"
}
</code></pre>

<p>This returns an array-like object of type <code>ActiveRecord::Result</code>. Each item in
the collection is a <code>Hash</code> representing a row in the results.</p>

<p>The <code>ActiveRecord::Result</code> contains information about the table and its columns.
It knows how to convert column values to <em>some of</em> their corresponding Ruby
types.</p>

<h3>#execute</h3>

<pre><code class="ruby">users = ActiveRecord::Base.connection.execute("SELECT id, first_name, created_at FROM users WHERE id=1")

users[0]
{
  "id"         =&gt; "1",
  "first_name" =&gt; "Trystan",
  "created_at" =&gt; "2015-09-05 15:44:51.597326"
}
</code></pre>

<p>This returns an array-like object that is specific on the database driver. For
PostgreSQL, this will be a <code>PG::Result</code>. Each item in the collection is a
<code>Hash</code>. The values of the Hash are strings and nils. No conversion is performed
to convert the values to the appropriate Ruby type, other than NULL to nil.</p>

<h3>#quote</h3>

<p>The <code>select_all</code> and <code>execute</code> methods have no built-in mechanism for escaping
values for the SQL statement.</p>

<p>Something like this is bad practice:</p>

<pre><code class="ruby">users = ActiveRecord::Base.connection.select_all("
  SELECT * FROM users WHERE email='#{email}'")
</code></pre>

<p>Because we&rsquo;re not sure what is in <code>email</code>. It could have an SQL injection
attack, or it could just have unexpected characters that will break
the query. To cover these
cases, ActiveRecord provides <code>#quote</code>:</p>

<pre><code class="ruby">conn = ActiveRecord::Base.connection
users = conn.select_all("
  SELECT * FROM users WHERE email=#{conn.quote(email)}")
</code></pre>

<p>Notice that the SQL statement does not have single quote marks around the email.
<code>#quote</code> does that automatically.</p>

<h3>#sanitize_sql_array</h3>

<p>Using <code>#quote</code> can get unwieldy as more and more values need to be escaped.
There is a private method called <code>#sanitize_sql_array</code> that brings back the
parameterized escape mechanism that is present in ActiveRecord&rsquo;s higher-level
API.</p>

<pre><code class="ruby">sql = ActiveRecord::Base.send(:sanitize_sql_array,
  ["SELECT * FROM users WHERE email=?", email])

users = ActiveRecord::Base.connection.select_all(sql)
</code></pre>

<h3>#connection_config</h3>

<p>Sometimes you need to introspect the database connection details. Maybe you have an external utility that performs bulk operations against the database, and
it bypasses ActiveRecord entirely.</p>

<pre><code class="ruby">config = Rails.application.config.database_configuration

{
  "common" =&gt; {
    "adapter"           =&gt; "postgres",
    "encoding"          =&gt; "utf8",
    "postgis_extension" =&gt; true,
    "username"          =&gt; "user",
    "password"          =&gt; "password",
    "host"              =&gt; "127.0.0.1",
    "port"              =&gt; 5432
  },
  "development" =&gt; {
    "adapter"           =&gt; "postgres",
    "encoding"          =&gt; "utf8",
    "postgis_extension" =&gt; true,
    "username"          =&gt; "user",
    "password"          =&gt; "password",
    "host"              =&gt; "127.0.0.1",
    "port"              =&gt; 5432,
    "database"          =&gt; "database_development"    
  },
  "production" =&gt; {
    "adapter"           =&gt; "postgres",
    "encoding"          =&gt; "utf8",
    "postgis_extension" =&gt; true,
    "username"          =&gt; "user",
    "password"          =&gt; "password",
    "host"              =&gt; "127.0.0.1",
    "port"              =&gt; 5432,
    "database"          =&gt; "database_production"    
  }
}
</code></pre>

<h2>#with_connection</h2>

<p>Using a database connection and not returning is like opening a file and not
closing it. It can lead to connection leaks in some contexts.
ActiveRecord provides a block-style pattern for using a database connection:</p>

<pre><code class="ruby">ActiveRecord::Base.connection_pool.with_connection do |conn|
  users = conn.select_all("
    SELECT * FROM users WHERE email=#{conn.quote(email)}")
end
</code></pre>

<h2>#structure_load</h2>

<p>For times when you need to load a bunch of SQL statements from a file,
ActiveRecord provides <code>#structure_load</code>:</p>

<pre><code class="ruby">config = Rails.application.config.database_configuration['development']
sql_file = "tmp/foo.sql"
ActiveRecord::Tasks::DatabaseTasks.structure_load(config, sql_file)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding the Source for a Given Rails Web Page]]></title>
    <link href="http://www.moxleystratton.com/blog/2014/05/29/finding-the-source-for-a-given-rails-web-page/"/>
    <updated>2014-05-29T12:00:00-07:00</updated>
    <id>http://www.moxleystratton.com/blog/2014/05/29/finding-the-source-for-a-given-rails-web-page</id>
    <content type="html"><![CDATA[<p>These tips may help those of you who are relatively new to Rails, or maybe even if you&rsquo;re not.</p>

<!-- more -->


<h2>Common tips and tricks</h2>

<ul>
<li>Look at the URL path (e.g. <code>/users/100685/edit</code>).
Can the action and main view file be determined from CRUD/REST conventions?

<ul>
<li><code>/:model/edit</code> -> edit.html.slim</li>
<li><code>/:model/1234</code> -> show.html.slim</li>
<li><code>/:model/new</code> -> new.html.slim</li>
<li><code>/:model</code> -> index.html.slim</li>
</ul>
</li>
<li>Look up the path in routes.rb, or even more useful, run <code>rake routes</code></li>
</ul>


<h2>Finding a controller and action responsible for a given page</h2>

<ol>
<li>In development go to your server&rsquo;s output, and clear the screen (<code>Ctrl+L</code>,
for Linux, <code>Cmd-K</code> for OS X)</li>
<li>Refresh the web page</li>
<li>Back to the server&rsquo;s output, scroll to the top of the output. About the second
line of non-blank log output, you should see something like:
<code>Processing by UserseController#edit as HTML</code>. That&rsquo;s the
controller (<code>UsersController</code>) and action (<code>edit</code>).</li>
</ol>


<h2>Finding a view file for a given page</h2>

<ul>
<li>If in development, look at the server log. If it is too noisy, use
<code>tail -f log/development | grep Rendered</code> to cut out the noise.</li>
<li>If in development, add the <code>rails_view_annotator</code> gem to your Gemfile,
and look at the DOM or HTML source. It should have HTML comments identifying
the view partials responsible for their generated HTML.</li>
</ul>

]]></content>
  </entry>
  
</feed>
